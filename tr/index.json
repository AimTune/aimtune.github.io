[{"content":" OpenTelemetry Nedir? # Open aÃ§Ä±k kaynak olmasÄ±nÄ±, Tele uzaktan yapabilmesini ve Metry (Metron) Ã¶lÃ§Ã¼mÃ¼ temsil eder. Bir gÃ¶zlemlenebilirlik (observability) frameworkâ€™Ã¼dÃ¼r\nLog, trace ve metrics verilerini platform baÄŸÄ±msÄ±z, standart bir formatta Ã¼reterek istenilen hedefe aktarabilmeyi saÄŸlar.\nHer dilin kÃ¼tÃ¼phanesi farklÄ± veri formatlarÄ± oluÅŸturabilirken, OpenTelemetry bu verileri tek bir standarda oturtur.\nOpenTelemetry Nedir? # CNCF (Cloud Native Computing Foundation) tarafÄ±ndan desteklenir ve APM araÃ§larÄ±ndan baÄŸÄ±msÄ±z Ã§alÄ±ÅŸÄ±r.\nOTLP protokolÃ¼ sayesinde endÃ¼stri standartlarÄ±nda veri toplayabilir.\nJaeger ve Zipkin gibi araÃ§larla uyumlu Ã§alÄ±ÅŸarak kapsamlÄ± bir gÃ¶zlemlenebilirlik Ã§Ã¶zÃ¼mÃ¼ sunar.\nAPM (Application Performance Monitoring) AraÃ§larÄ± # Jaeger ve Zipkin: Ã–zellikle tracing iÃ§in kullanÄ±lan aÃ§Ä±k kaynaklÄ± platformlardÄ±r. OpenTelemetry\u0026rsquo;le uyumludurlar.\nJaeger: Cassandra ve Elasticsearch gibi veri depolarÄ±nÄ± destekler.\nZipkin: Tracing tarafÄ±nda yine popÃ¼ler aÃ§Ä±k kaynak bir Ã§Ã¶zÃ¼mdÃ¼r.\nÃ–zellikle bu iki araÃ§ log verisi istemezler; daha Ã§ok trace odaklÄ± Ã§alÄ±ÅŸÄ±rlar.\nAPM (Application Performance Monitoring) AraÃ§larÄ± # Elastic APM: Elastic tarafÄ±ndan geliÅŸtirilen bir Application Performance Monitoring Ã§Ã¶zÃ¼mÃ¼dÃ¼r. UygulamalarÄ±n performansÄ±nÄ±, hatalarÄ±nÄ± ve iÅŸlemler arasÄ±ndaki gecikmeleri izleyebilmek iÃ§in distribute tracing, log analizi ve metrik toplama Ã¶zelliklerini bir arada sunar. APM (Application Performance Monitoring) AraÃ§larÄ± # New Relic: SaaS tabanlÄ± bir Application Performance Monitoring platformudur. AnlÄ±k performans metrikleri, hata takibi ve geliÅŸmiÅŸ analiz araÃ§larÄ± sunarak uygulamanÄ±zÄ±n uÃ§tan uca izlenmesini saÄŸlar. Kod seviyesinde detaylÄ± tracing, kullanÄ±labilirlik Ã¶lÃ§Ã¼mleri, gecikme analizleri gibi Ã¶zelliklerle performans sorunlarÄ±nÄ± hÄ±zlÄ±ca tespit etmeye yardÄ±mcÄ± olur. APM (Application Performance Monitoring) AraÃ§larÄ± # Application Insights: Microsoft Azure ekosisteminin bir parÃ§asÄ± olan Application Insights, canlÄ± uygulamalarÄ±n performans ve kullanÄ±m verilerini izlemek iÃ§in kullanÄ±lan bir APM hizmetidir. KullanÄ±cÄ± davranÄ±ÅŸlarÄ±nÄ±, istek performansÄ±nÄ± ve hatalarÄ± gerÃ§ek zamanlÄ± olarak takip etmeyi saÄŸlar. AyrÄ±ca, Azureâ€™un diÄŸer hizmetleriyle entegre Ã§alÄ±ÅŸarak merkezi izleme, uyarÄ± mekanizmalarÄ± ve veri analizi imkanlarÄ± sunar. APM (Application Performance Monitoring) AraÃ§larÄ± # Bu tÃ¼m araÃ§larg genellikle Ã¶nce gelen veri paketlerini kaydeder, sonrasÄ±nda da indexleyerek sorgulanabilir ve gÃ¶rselleÅŸtirilebilir hale getirir. Trace Data Nedir? # Tracing, loglarÄ±n daha Ã¶zelleÅŸmiÅŸ bir formudur ve uygulamada meydana gelen olaylarÄ± daha detaylÄ± biÃ§imde gÃ¶sterir. Bu sayede performansla ilgili problemleri, hangi adÄ±mda gecikme yaÅŸandÄ±ÄŸÄ±nÄ± ve iÅŸlemlerin genel gidiÅŸatÄ±nÄ± inceleyebilirsiniz. .NET 5 Ã¶ncesindeki projelerde, System.Diagnostic.DiagnosticSource paketine ihtiyaÃ§ duyulur. Trace Data Ä°Ã§eriÄŸi #Bir trace, uygulamanÄ±n farklÄ± katmanlarÄ± veya bileÅŸenleri arasÄ±ndaki etkileÅŸimleri ayrÄ±ntÄ±lÄ± bir ÅŸekilde gÃ¶sterir. Ã–rneÄŸin:\nHTTP Request: Ä°steÄŸin gÃ¶nderilme ve alÄ±nma sÃ¼resi. HTTP Response: DÃ¶nen cevabÄ±n iÃ§eriÄŸi ve genel yanÄ±t sÃ¼resi. Trace Data Ä°Ã§eriÄŸi # VeritabanÄ± Ä°ÅŸlemleri (DB): KomutlarÄ±n (query, insert, update vb.) ne kadar sÃ¼rdÃ¼ÄŸÃ¼ ve hangi tablolarÄ±n etkilendiÄŸi. BaÅŸka Bir API\u0026rsquo;ye Ã‡aÄŸrÄ± (Another API): Harici servis veya mikroservis iletiÅŸimi. Metot Ã‡aÄŸrÄ±larÄ± (Method): Metot iÃ§erisinde gerÃ§ekleÅŸen adÄ±mlar, parametreler ve sÃ¼re bilgisi. Queue Ä°ÅŸlemleri (Queue): SÄ±ralarda bekleyen mesajlar, gÃ¶nderim ve tÃ¼ketim sÃ¼releri. Trace Data Ä°Ã§eriÄŸi #Bu veriler, tek bir zincir (trace) Ã¼zerinde segmentler (span) ÅŸeklinde toplanÄ±r ve bÃ¶ylelikle uÃ§tan uca bir gÃ¶rÃ¼nÃ¼rlÃ¼k elde etmenizi saÄŸlar.\n","date":"1 Ocak 1","permalink":"/tr/presentations/distributed-system-series/observability/opentelemetry/","section":"Presentations","summary":"OpenTelemetry Nedir? # Open aÃ§Ä±k kaynak olmasÄ±nÄ±, Tele uzaktan yapabilmesini ve Metry (Metron) Ã¶lÃ§Ã¼mÃ¼ temsil eder. Bir gÃ¶zlemlenebilirlik (observability) frameworkâ€™Ã¼dÃ¼r\nLog, trace ve metrics verilerini platform baÄŸÄ±msÄ±z, standart bir formatta Ã¼reterek istenilen hedefe aktarabilmeyi saÄŸlar.\nHer dilin kÃ¼tÃ¼phanesi farklÄ± veri formatlarÄ± oluÅŸturabilirken, OpenTelemetry bu verileri tek bir standarda oturtur.\nOpenTelemetry Nedir? # CNCF (Cloud Native Computing Foundation) tarafÄ±ndan desteklenir ve APM araÃ§larÄ±ndan baÄŸÄ±msÄ±z Ã§alÄ±ÅŸÄ±r.\nOTLP protokolÃ¼ sayesinde endÃ¼stri standartlarÄ±nda veri toplayabilir.","title":""},{"content":" Kurulum # Bu paketleri yÃ¼klÃ¼yoruz.\nConsole Demo # Console Demo # OpenTelemetry\u0026rsquo;deki Temel Kavramlar # Resource Nedir ve NasÄ±l YapÄ±landÄ±rÄ±lÄ±r? #OpenTelemetryâ€™de Resource, hangi servis veya uygulamanÄ±n veri Ã¼rettiÄŸini tanÄ±mlayan ve telemetri (Trace, Metrics, Logs) verilerine baÄŸlam kazandÄ±ran meta bilgileri iÃ§erir. Bu sayede, Ã¼rettiÄŸiniz verilerin hangi servis tarafÄ±ndan, hangi sÃ¼rÃ¼mde, hangi ortamda (Ã¶rn. dev, preprod, prod) veya hangi instance (kopya) Ã¼zerinden geldiÄŸini anlayabilirsiniz.\nResource Ãœzerinde TanÄ±mlanabilen Bilgiler # Service Name\nUygulama veya servisin adÄ±. (Ã–rneÄŸin: PaymentService) Service Version\nUygulamanÄ±n hangi sÃ¼rÃ¼mÃ¼nÃ¼n Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± belirtir. (Ã–rneÄŸin: 1.0.0) Resource Ãœzerinde TanÄ±mlanabilen Bilgiler # Namespace\nBir uygulama veya servis ailesinin/alanÄ±nÄ±n adÄ± olarak dÃ¼ÅŸÃ¼nebilirsiniz. (Ã–rneÄŸin: MyCompanyName.PaymentSystem) Instance\nServisin belirli bir kopyasÄ±. (Ã–rneÄŸin: payment-service-instance-2) Resource Ãœzerinde TanÄ±mlanabilen Bilgiler # Deployment Environment (Ã¶rn. dev, preprod, prod) Static property olarak veya deÄŸiÅŸken Ã¼zerinden tanÄ±mlayabilirsiniz. BÃ¶ylece telemetri verilerinin hangi ortamdan geldiÄŸi kolayca anlaÅŸÄ±lÄ±r. Ã–rnek Resource TanÄ±mÄ± #var tracerProvider = Sdk.CreateTracerProviderBuilder() .SetResourceBuilder( ResourceBuilder.CreateDefault() .AddService( serviceName: \u0026quot;PaymentService\u0026quot;, serviceVersion: \u0026quot;1.0.0\u0026quot;) .AddAttributes(new Dictionary\u0026lt;string, object\u0026gt; { [\u0026quot;deployment.environment\u0026quot;] = \u0026quot;dev\u0026quot;, // Ortam bilgisi [\u0026quot;service.instance.id\u0026quot;] = \u0026quot;instance-001\u0026quot; // Instance }) ) // Exporter vb. diÄŸer ayarlar .AddConsoleExporter() .Build(); AgentSource (TraceProvider) # TanÄ±m: Uygulamada trace verilerinin Ã¼retildiÄŸi ana sÄ±nÄ±flardÄ±r. AmaÃ§: Trace verilerini oluÅŸturarak, hangi iÅŸlemlerin ne kadar sÃ¼rdÃ¼ÄŸÃ¼nÃ¼ ve hangi bileÅŸenler arasÄ±nda gerÃ§ekleÅŸtiÄŸini izlememizi saÄŸlar. AgentSource (TraceProvider) # TasarÄ±m: Static veya Singleton ÅŸeklinde tasarlanmalÄ±dÄ±r, bÃ¶ylece uygulama iÃ§inde merkezi ve tutarlÄ± bir yerden yÃ¶netilebilir. Benzer ÅŸekilde, namespace yapÄ±sÄ±nÄ± kullanarak farklÄ± traceleri mantÄ±ksal olarak ayÄ±rabilir veya gruplandÄ±rabilirsiniz. AgentSource (TraceProvider) # Faydalar: UygulamanÄ±n belirli kÄ±sÄ±mlarÄ±ndan veya mikroservislerden Ã¼retilen verileri daha dÃ¼zenli takip etme olanaÄŸÄ± sunar. Tek noktada konfigÃ¼re edildiÄŸinden, kaynak yÃ¶netimi (Ã¶rneÄŸin, tek bir Tracer Provider Ã¼zerinden farklÄ± bileÅŸenlerin izlenmesi) kolaylaÅŸÄ±r. Åeffaf gÃ¶zlemlenebilirlik elde etmeye yardÄ±mcÄ± olur, Ã§Ã¼nkÃ¼ tÃ¼m izleme (tracing) aktiviteleri ortak bir kayÄ±t noktasÄ± Ã¼zerinden yÃ¶netilir. Activity (Span) # Uygulamadaki her bir operasyon, bir span (Ã¶rneÄŸin: HTTP isteÄŸi, veritabanÄ± Ã§aÄŸrÄ±sÄ±, dosya yazma) ÅŸeklinde temsil edilir. Bu spanâ€™lerin bir araya gelmesiyle bir trace (iÅŸlem bÃ¼tÃ¼nlÃ¼ÄŸÃ¼) oluÅŸur. Span Ä°Ã§eriÄŸi # Start-end time: Spanâ€™in baÅŸlama ve bitiÅŸ zamanÄ± Success-failure: Ä°ÅŸlemin baÅŸarÄ±lÄ± mÄ± yoksa hatalÄ± mÄ± sonuÃ§landÄ±ÄŸÄ± Span kind: Spanâ€™in rolÃ¼ (client, server, consumer, producer, internal) Attributes/Tags: Operasyona dair ek bilgiler (Ã¶rn. kullanÄ±cÄ± kimliÄŸi, sÃ¼rÃ¼m bilgisi vb.) Events: Span sÃ¼recindeki belirli olaylar veya kontrol noktalarÄ± (checkpoints) Span ve Trace ArasÄ±ndaki Ä°liÅŸki # Span: Tek bir operasyonu temsil eder. Trace: Birden fazla spanâ€™in birleÅŸerek oluÅŸturduÄŸu, uÃ§tan uca bÃ¼tÃ¼n bir iÅŸlemi ifade eder. Activity (Span) Kind # Internal: Uygulama iÃ§indeki dahili bir iÅŸlemi ifade eder. Server: Ä°stekleri sunucu tarafÄ±nda karÅŸÄ±layan veya iÅŸleyen taraftÄ±r. Client: DÄ±ÅŸ bir kaynaÄŸa veya hizmete istek gÃ¶nderen taraftÄ±r. Producer: Mesaj veya veri Ã¼reterek bir kuyruÄŸa, topicâ€™e veya baÅŸka bir yere yayÄ±mlayan taraftÄ±r. Consumer: YayÄ±nlanmÄ±ÅŸ mesajlarÄ± veya eventâ€™leri alan ve iÅŸleyen taraftÄ±r. Event # Event, bir spanâ€™in (Activity) iÃ§erisindeki belirli bir olayÄ± veya noktayÄ± temsil eder. Log benzeri bir yapÄ±sÄ± olsa da in-memory tutulduÄŸu iÃ§in (doÄŸrudan bellekte saklanÄ±r), Ã§ok sÄ±k kullanÄ±lmasÄ± yÃ¼ksek maliyet doÄŸurabilir. Ã–rneÄŸin, â€œBu dosyayÄ± oluÅŸturdum, boyutu 50 KBâ€ ÅŸeklindeki bir bilgiyi Event olarak ekleyebilirsiniz. Activity(Span) Status #Bir spanâ€™in durumunu belirlemek iÃ§in Ã¼Ã§ temel Status tipi vardÄ±r:\nOk Error Unset BaÅŸarÄ±sÄ±z bir iÅŸlem (Ã¶r. istisna, hata kodu) oluÅŸtuÄŸunda span durumunu Error olarak ayarlayabilirsiniz.\nTag (Attributes) # Spanâ€™e ek bilgi (metadata) eklemek iÃ§in kullanÄ±lÄ±r. Ã–rnek: SipariÅŸ ID, kullanÄ±cÄ± ID, iÅŸlem tÃ¼rÃ¼ gibi bilgileri, span ile iliÅŸkilendirerek daha ayrÄ±ntÄ±lÄ± takip edebiliriz. Ä°leride analiz yaparken veya sorun giderirken, bu etiketler sayesinde hangi iÅŸlemin hangi kullanÄ±cÄ± veya sipariÅŸle ilgili olduÄŸunu hÄ±zlÄ±ca bulabilirsiniz. Correlations (In-Process) # Bir uygulama iÃ§indeki veya farklÄ± servisler arasÄ±ndaki spanâ€™lerin birbirine baÄŸlÄ± olduÄŸu durumu ifade eder. Ä°stek, bir servis/uygulamadan diÄŸerine aktarÄ±ldÄ±ÄŸÄ±nda, traceId paylaÅŸÄ±lÄ±r ve bÃ¶ylece bÃ¼tÃ¼n istek zinciri aynÄ± iz (trace) altÄ±nda toplanÄ±r. Bu sayede APM (Application Performance Monitoring) araÃ§larÄ±nda tek bir iz (trace) iÃ§erisinde, Ã§oklu servis ve iÅŸlem adÄ±mlarÄ±nÄ± uÃ§tan uca takip edebilirsiniz. Activity.Current # TanÄ±m: .NET uygulamalarÄ±nda halihazÄ±rda etkin (aktif) olan Activity nesnesine (span) eriÅŸim saÄŸlar. KullanÄ±m: AÅŸaÄŸÄ±daki Ã¶rnek, Activity.Current Ã¼zerinden mevcut iÅŸlem (span) bilgisini elde etmeye yarar. Ã–rneÄŸin, etiket eklemek veya durum gÃ¼ncellemesi yapmak istediÄŸinizde Activity.Current?.SetTag(\u0026quot;key\u0026quot;, \u0026quot;value\u0026quot;) ÅŸeklinde Ã§aÄŸrÄ± yapabilirsiniz. Activity.Current # Ã–rnek Senaryo: Bir HTTP isteÄŸi geldiÄŸinde, yeni bir Activity baÅŸlatÄ±lÄ±r (veya otomatik baÅŸlatÄ±lÄ±r). Bu sÃ¼reÃ§te, Activity.Current o anki isteÄŸi temsil eden spanâ€™i gÃ¶sterir. Ek etiketler, eventâ€™ler veya hata durumlarÄ±yla ilgili kayÄ±tlar bu aktif Activity Ã¼zerinden yapÄ±lÄ±r. Ã–nemli Not: Activity.Current, her zaman aktif bir iÅŸlem (span) olmayabilir. Bu nedenle, kod yazarken null durumlarÄ±nÄ± dikkate almak gereklidir.\nActivityListener # TanÄ±m: .NET uygulamalarÄ±nda, oluÅŸturulan veya bitirilen Activity (yani Span) nesnelerini dinlemek (listen) ve yÃ¶netmek iÃ§in kullanÄ±lan bir mekanizmadÄ±r. AmaÃ§: Uygulamada hangi Activityâ€™lerin (iÅŸlemlerin) izlenmesi, Ã¶rneÄŸin hangilerinin kaydedilmesi veya kaydedilmemesi gerektiÄŸine karar vermenizi saÄŸlar. ActivityListener # NasÄ±l Ã‡alÄ±ÅŸÄ±r: ActivityListener nesnesi oluÅŸturulur. Ä°lgili geribildirim (callback) yÃ¶ntemleri tanÄ±mlanÄ±r, Ã¶rneÄŸin: ShouldListenTo (hangi ActivitySourceâ€™larÄ± dinlemek istediÄŸimizi belirtir) Sample (hangi Activityâ€™lerin baÅŸlatÄ±lÄ±p baÅŸlatÄ±lmayacaÄŸÄ±na karar verir) ActivityStarted/ActivityStopped (bir Activity baÅŸladÄ±ÄŸÄ±nda veya bittiÄŸinde Ã§alÄ±ÅŸacak event metodlarÄ±) Bu listener, ActivitySource nesnesine veya genel ActivitySource.AddActivityListener(activityListener) gibi bir API Ã¼zerinden eklenir. Ã–rnek KullanÄ±m #using System; using System.Diagnostics; public class ActivityListenerExample { public static void SetupListener() { var listener = new ActivityListener { // Hangi ActivitySource'larÄ± dinleyeceÄŸimize karar veriyoruz. ShouldListenTo = (activitySource) =\u0026gt; { // Ã–rneÄŸin, \u0026quot;MyCompany.MyApp\u0026quot; adÄ±ndaki ActivitySourceâ€™lara izin ver return activitySource.Name.Contains(\u0026quot;MyCompany.MyApp\u0026quot;); }, // Activity oluÅŸturulmadan Ã¶nce â€œÃ¶rneklemeâ€ kararÄ± veriyoruz (Ã¶r. kaydetsin mi kaydetmesin mi). Sample = (ref ActivityCreationOptions\u0026lt;ActivityContext\u0026gt; options) =\u0026gt; { // Belli bir mantÄ±ÄŸa gÃ¶re (Ã¶r. rastgele yÃ¼zdelik, environment bilgisi vb.) karar verebilirsiniz. // Ã–rnekte tÃ¼m Activity'leri kaydediyoruz: return ActivitySamplingResult.AllDataAndRecorded; }, // Activity baÅŸladÄ±ÄŸÄ±nda Ã§alÄ±ÅŸacak callback ActivityStarted = activity =\u0026gt; { Console.WriteLine($\u0026quot;Activity Started: {activity.DisplayName}\u0026quot;); }, // Activity bittiÄŸinde Ã§alÄ±ÅŸacak callback ActivityStopped = activity =\u0026gt; { Console.WriteLine($\u0026quot;Activity Stopped: {activity.DisplayName}\u0026quot;); } }; // Listener'Ä± default ActivitySource'a ekliyoruz. ActivitySource.AddActivityListener(listener); } } Bu Ã–rnekte # ShouldListenTo: Hangi ActivitySourceâ€™larÄ± dinlemek istediÄŸimizi belirtiyoruz. Sample: Hangi Activityâ€™lerin gerÃ§ekten oluÅŸturulacaÄŸÄ±nÄ± veya kaydedileceÄŸini kontrol edebiliyoruz. ActivityStarted ve ActivityStopped: OluÅŸturulan Activityâ€™lerin baÅŸlangÄ±Ã§ ve bitiÅŸ anlarÄ±nda Ã¶zel iÅŸlem yapabiliyoruz (Ã¶rnek olarak konsola yazma). Neden Ã–nemli? # Filtreleme: Ã‡ok fazla Activity oluÅŸturulduÄŸunda, dinlemek istediklerimizi kÄ±sÄ±tlayarak sistem yÃ¼kÃ¼nÃ¼ azaltabilirsiniz. Merkezi YÃ¶netim: Tracing mantÄ±ÄŸÄ±nÄ± uygulamanÄ±n Ã§eÅŸitli yerlerine serpmek yerine, tek bir noktadan (ActivityListener) yÃ¶netebilirsiniz. Neden Ã–nemli? # Esneklik: GerÃ§ek zamanlÄ± olarak hangi spanâ€™lerin kaydedilmesi gerektiÄŸini deÄŸiÅŸtirerek (Ã¶rneÄŸin, hata modunda tÃ¼m tracingâ€™i aktif hale getirerek) sistem davranÄ±ÅŸÄ±nÄ± dinamik olarak ayarlayabilirsiniz. Ä°nce Ayar: Ã–zel mantÄ±klar (Ã¶r. belirli bir kullanÄ±cÄ±ya veya sipariÅŸe ait Activityâ€™leri kaydetme) tanÄ±mlayarak ince dÃ¼zeyde kontrol saÄŸlayabilirsiniz. ","date":"1 Ocak 1","permalink":"/tr/presentations/distributed-system-series/observability/opentelemetry-net/","section":"Presentations","summary":"Kurulum # Bu paketleri yÃ¼klÃ¼yoruz.\nConsole Demo # Console Demo # OpenTelemetry\u0026rsquo;deki Temel Kavramlar # Resource Nedir ve NasÄ±l YapÄ±landÄ±rÄ±lÄ±r? #OpenTelemetryâ€™de Resource, hangi servis veya uygulamanÄ±n veri Ã¼rettiÄŸini tanÄ±mlayan ve telemetri (Trace, Metrics, Logs) verilerine baÄŸlam kazandÄ±ran meta bilgileri iÃ§erir. Bu sayede, Ã¼rettiÄŸiniz verilerin hangi servis tarafÄ±ndan, hangi sÃ¼rÃ¼mde, hangi ortamda (Ã¶rn. dev, preprod, prod) veya hangi instance (kopya) Ã¼zerinden geldiÄŸini anlayabilirsiniz.\nResource Ãœzerinde TanÄ±mlanabilen Bilgiler # Service Name","title":""},{"content":" Jaeger ve Elastic APM Kurulumu #AÅŸaÄŸÄ±da, hem Jaeger hem de Elastic APM iÃ§in temel kurulum Ã¶rneklerini bulabilirsiniz. Bu Ã¶rnekler, hÄ±zlÄ± bir ÅŸekilde lokal ortamda Ã§alÄ±ÅŸtÄ±rmak veya test amaÃ§lÄ± yapÄ±landÄ±rmak iÃ§indir. Ãœretim ortamÄ±na uygun daha detaylÄ± kurulumlar iÃ§in resmi dokÃ¼manlarÄ± inceleyebilirsiniz.\n1. Jaeger Kurulumu #Docker Compose ile Jaegerâ€™i hÄ±zlÄ±ca Ã§alÄ±ÅŸtÄ±rmak iÃ§in Ã¶rnek bir docker-compose.yml dosyasÄ±:\nversion: '3' services: jaeger: image: jaegertracing/all-in-one:1.21 environment: - COLLECTOR_ZIPKIN_HOST_PORT=:9411 # Zipkin HTTP endpoint'i iÃ§in kullanÄ±lan port ayarÄ± (9411). ports: - \u0026quot;16686:16686\u0026quot; # Jaeger web arayÃ¼zÃ¼ - \u0026quot;4317:4317\u0026quot; # OTLP Collector (gRPC) - \u0026quot;4318:4318\u0026quot; # OTLP Collector (HTTP) - \u0026quot;14250:14250\u0026quot; # Collector (model.proto) - \u0026quot;14268:14268\u0026quot; # Collector (jaeger.thrift) - \u0026quot;14269:14269\u0026quot; # Collector (SPM) - \u0026quot;9411:9411\u0026quot; # Collector (Zipkin) 2. Elastic APM Stack Kurulumu #version: '3' services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:8.9.0 container_name: elasticsearch environment: - discovery.type=single-node - xpack.security.enabled=false ports: - \u0026quot;9200:9200\u0026quot; kibana: image: docker.elastic.co/kibana/kibana:8.9.0 container_name: kibana environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 - xpack.security.enabled=false ports: - \u0026quot;5601:5601\u0026quot; depends_on: - elasticsearch apm-server: image: docker.elastic.co/apm/apm-server:8.9.0 container_name: apm-server environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 - output.elasticsearch.enabled=true - output.elasticsearch.hosts=[\u0026quot;elasticsearch:9200\u0026quot;] - apm-server.secret_token=some_secret_token - xpack.security.enabled=false ports: - \u0026quot;8200:8200\u0026quot; depends_on: - elasticsearch ","date":"1 Ocak 1","permalink":"/tr/presentations/distributed-system-series/observability/opentelemetry-devops/","section":"Presentations","summary":"Jaeger ve Elastic APM Kurulumu #AÅŸaÄŸÄ±da, hem Jaeger hem de Elastic APM iÃ§in temel kurulum Ã¶rneklerini bulabilirsiniz. Bu Ã¶rnekler, hÄ±zlÄ± bir ÅŸekilde lokal ortamda Ã§alÄ±ÅŸtÄ±rmak veya test amaÃ§lÄ± yapÄ±landÄ±rmak iÃ§indir. Ãœretim ortamÄ±na uygun daha detaylÄ± kurulumlar iÃ§in resmi dokÃ¼manlarÄ± inceleyebilirsiniz.\n1. Jaeger Kurulumu #Docker Compose ile Jaegerâ€™i hÄ±zlÄ±ca Ã§alÄ±ÅŸtÄ±rmak iÃ§in Ã¶rnek bir docker-compose.yml dosyasÄ±:\nversion: '3' services: jaeger: image: jaegertracing/all-in-one:1.21 environment: - COLLECTOR_ZIPKIN_HOST_PORT=:9411 # Zipkin HTTP endpoint'i iÃ§in kullanÄ±lan port ayarÄ± (9411).","title":""},{"content":" Instrumentations Nedir? #Instrumentations, bir uygulamanÄ±n belirli bÃ¶lÃ¼mlerini (Ã¶r. ASP.NET Core, HttpClient, Entity Framework, Redis, RabbitMQ) otomatik olarak izlenebilir hÃ¢le getiren bileÅŸenler veya kÃ¼tÃ¼phanelerdir. Bu sayede, uygulamanÄ±zÄ±n farklÄ± katmanlarÄ±nda (Ã¶r. web istekleri, veri tabanÄ± iÅŸlemleri, mesaj kuyruÄŸu vb.) gerÃ§ekleÅŸen olaylar ve performans metrikleri otomatik olarak toplanÄ±r ve kaydedilir.\nNeden Gerekli? UygulamanÄ±n kritik noktalarÄ±nÄ± (API Ã§aÄŸrÄ±larÄ±, veritabanÄ± sorgularÄ±, mesaj kuyruÄŸu iÅŸlemleri vb.) tek tek manuel kodlamadan izlemeye olanak tanÄ±r. Performans sorunlarÄ±nÄ± veya hatalarÄ± hÄ±zlÄ± bir ÅŸekilde tespit edip kÃ¶k neden analizi (root cause analysis) yapmak kolaylaÅŸÄ±r. NasÄ±l Ã‡alÄ±ÅŸÄ±r? GeliÅŸtiriciler, ilgili instrumentation paketini projeye ekler (NuGet). Uygulamaya, konfigÃ¼rasyonla hangi bileÅŸenlerin izleneceÄŸi belirtilir (AddAspNetCoreInstrumentation, AddHttpClientInstrumentation, vb.). Toplanan veriler, tercihe gÃ¶re Jaeger, Zipkin, Elastic APM gibi dÄ±ÅŸ araÃ§lara veya konsola gÃ¶nderilir (export edilir). Ã–zetle: Instrumentations, uygulamanÄ±zdaki karmaÅŸÄ±k iÅŸlemleri elle uÄŸraÅŸmadan otomatik olarak Ã¶lÃ§Ã¼mleyerek daha kolay gÃ¶zlemleme (observability) saÄŸlar.\nÃ–ncelikle bu paketleri yÃ¼klÃ¼yoruz.\nInstrumentations #AÅŸaÄŸÄ±da .NET projelerinde sÄ±kÃ§a kullanÄ±lan instrumentation (izleme/Ã¶lÃ§Ã¼m) seÃ§eneklerini Ã¶zetliyoruz. Bu bileÅŸenler, OpenTelemetry veya benzeri kÃ¼tÃ¼phaneler aracÄ±lÄ±ÄŸÄ±yla uygulamanÄ±n Ã¶nemli noktalarÄ±nÄ± (HTTP istekleri, veritabanÄ± iÅŸlemleri, mesaj kuyruÄŸu iÅŸlemleri vb.) otomatik veya yarÄ± otomatik bir ÅŸekilde izlenebilir hÃ¢le getirir.\n1. ASP.NET Core Instrumentation # AmaÃ§: ASP.NET Core uygulamanÄ±zÄ±n HTTP isteklerinin sÃ¼resini, yanÄ±t kodlarÄ±nÄ± ve performansÄ±nÄ± otomatik olarak Ã¶lÃ§mek. Neler Ã–lÃ§Ã¼lÃ¼r? Giden/gelen HTTP istekleri Ä°stek baÅŸlama ve bitiÅŸ zamanÄ± YanÄ±t durum kodu (Ã¶r. 200, 404, 500) Ä°stek baÅŸlÄ±klarÄ± ve yol (endpoint) bilgileri 1. ASP.NET Core Instrumentation # Fayda: UygulamanÄ±za ek middleware eklemeden, out-of-the-box izleme alabilirsiniz. Hangi endpointâ€™lerin ne kadar sÄ±klÄ±kla ve hangi sÃ¼relerde Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶rebilirsiniz. 2. HttpClient Instrumentation # AmaÃ§: UygulamanÄ±z iÃ§indeki HttpClient Ã§aÄŸrÄ±larÄ±nÄ± izlemek ve performans sorunlarÄ±nÄ± tespit etmek. Neler Ã–lÃ§Ã¼lÃ¼r? YapÄ±lan dÄ±ÅŸ istek (URL), metot (GET, POST vb.) BaÅŸlangÄ±Ã§ ve bitiÅŸ zamanÄ± YanÄ±t kodu ve sÃ¼resi (latency) 2. HttpClient Instrumentation # Fayda: Mikroservisler veya harici APIâ€™lere yapÄ±lan Ã§aÄŸrÄ±larÄ± kolayca takip edersiniz. YanÄ±t sÃ¼resi uzun mu, hatalar hangi oranda gerÃ§ekleÅŸiyor vb. sorulara yanÄ±t bulabilirsiniz. 3. Entity Framework Instrumentation # AmaÃ§: Entity Framework (EF Core) ile yapÄ±lan veritabanÄ± iÅŸlemlerini (sorgu, ekleme, gÃ¼ncelleme) otomatik olarak izlemek. Neler Ã–lÃ§Ã¼lÃ¼r? OluÅŸturulan sorgular (SQL) Her sorgunun Ã§alÄ±ÅŸma sÃ¼resi (latency) Hata durumu (Ã¶r. time-out, baÄŸlantÄ± hatasÄ±) 3. Entity Framework Instrumentation # Fayda: VeritabanÄ± katmanÄ±ndaki performans darboÄŸazlarÄ±nÄ± (Ã¶rneÄŸin uzun sÃ¼ren sorgular) kolayca tespit edebilirsiniz. Tracing Ã¼zerinden hangi Ã¼st iÅŸlem (HTTP istek, background job vb.) sÄ±rasÄ±nda bu sorgularÄ±n tetiklendiÄŸini gÃ¶rebilirsiniz. 4. Redis Instrumentation # AmaÃ§: Redis kullanÄ±mÄ±yla ilgili performans ve hata gÃ¶zlemlemek (GET, SET, Publish/Subscribe vb.). Neler Ã–lÃ§Ã¼lÃ¼r? Redis komutlarÄ± (Ã¶rn. GET, SET, MGET, PUBLISH) Komutun baÅŸlangÄ±Ã§ ve bitiÅŸ zamanÄ± Hata durumlarÄ± (Ã¶r. baÄŸlantÄ± hatalarÄ±, time-out) 4. Redis Instrumentation # Fayda: Redis Ã§aÄŸrÄ±larÄ±nÄ±n ne kadar sÄ±k yapÄ±ldÄ±ÄŸÄ±nÄ± ve ne kadar sÃ¼rdÃ¼ÄŸÃ¼nÃ¼ tespit edebilirsiniz. UygulamanÄ±n nakit (cache) katmanÄ±nda olup bitenleri tek bir trace altÄ±nda izlemek mÃ¼mkÃ¼ndÃ¼r. 5. MassTransit Library Instrumentation # AmaÃ§: RabbitMQ Ã¼zerinden mesajlarÄ±n kuyruklanmasÄ± ve iÅŸlenmesi sÃ¼recini izlemek. MassTransit KÃ¼tÃ¼phanesi: .NET dÃ¼nyasÄ±nda RabbitMQ gibi mesajlaÅŸma altyapÄ±larÄ±na dair kolaylaÅŸtÄ±rÄ±cÄ± bir Ã§erÃ§eve (framework) sunar. 5. MassTransit Library Instrumentation # Neler Ã–lÃ§Ã¼lÃ¼r? KuyruÄŸa gÃ¶nderilen mesajlar (Publish/Send) TÃ¼ketici (Consumer) tarafÄ±ndan alÄ±nan mesajlarÄ±n iÅŸleme sÃ¼resi Hata durumlarÄ± (Ã¶r. ileti zaman aÅŸÄ±mÄ±, iÅŸleyici (handler) hatasÄ±) 5. MassTransit Library Instrumentation # Fayda: DaÄŸÄ±tÄ±k bir mimaride, mesajlarÄ±n uÃ§tan uca (publish -\u0026gt; queue -\u0026gt; consumer) hangi aÅŸamalardan geÃ§tiÄŸini gÃ¶rebilir, hangi aÅŸamada gecikme ya da hata oluÅŸtuÄŸunu tespit edebilirsiniz. MassTransit ile entegre bir ÅŸekilde izleme saÄŸlayarak, iÅŸ akÄ±ÅŸÄ±nÄ± (workflow) uÃ§tan uca izleyebilirsiniz. Ã–zetle, bu instrumentations sayesinde uygulamanÄ±n Ã¶nemli katmanlarÄ± (web istekleri, veritabanÄ±, mesaj kuyruÄŸu vb.) hakkÄ±nda ayrÄ±ntÄ±lÄ± telemetri verileri elde edebilir, hata ayÄ±klama ve performans analizi sÃ¼reÃ§lerinizi kolaylaÅŸtÄ±rabilirsiniz.\n","date":"1 Ocak 1","permalink":"/tr/presentations/distributed-system-series/observability/opentelemetry-instrumentations/","section":"Presentations","summary":"Instrumentations Nedir? #Instrumentations, bir uygulamanÄ±n belirli bÃ¶lÃ¼mlerini (Ã¶r. ASP.NET Core, HttpClient, Entity Framework, Redis, RabbitMQ) otomatik olarak izlenebilir hÃ¢le getiren bileÅŸenler veya kÃ¼tÃ¼phanelerdir. Bu sayede, uygulamanÄ±zÄ±n farklÄ± katmanlarÄ±nda (Ã¶r. web istekleri, veri tabanÄ± iÅŸlemleri, mesaj kuyruÄŸu vb.) gerÃ§ekleÅŸen olaylar ve performans metrikleri otomatik olarak toplanÄ±r ve kaydedilir.\nNeden Gerekli? UygulamanÄ±n kritik noktalarÄ±nÄ± (API Ã§aÄŸrÄ±larÄ±, veritabanÄ± sorgularÄ±, mesaj kuyruÄŸu iÅŸlemleri vb.) tek tek manuel kodlamadan izlemeye olanak tanÄ±r. Performans sorunlarÄ±nÄ± veya hatalarÄ± hÄ±zlÄ± bir ÅŸekilde tespit edip kÃ¶k neden analizi (root cause analysis) yapmak kolaylaÅŸÄ±r.","title":""},{"content":"","date":null,"permalink":"/tr/topics/apm/","section":"Topics","summary":"","title":"APM"},{"content":"","date":null,"permalink":"/tr/topics/distributed-systems/","section":"Topics","summary":"","title":"Distributed Systems"},{"content":"","date":null,"permalink":"/tr/","section":"Hamza AÄŸar","summary":"","title":"Hamza AÄŸar"},{"content":"","date":null,"permalink":"/tr/topics/logs/","section":"Topics","summary":"","title":"Logs"},{"content":"","date":null,"permalink":"/tr/topics/metrics/","section":"Topics","summary":"","title":"Metrics"},{"content":"","date":null,"permalink":"/tr/topics/monitoring/","section":"Topics","summary":"","title":"Monitoring"},{"content":"","date":null,"permalink":"/tr/topics/observability/","section":"Topics","summary":"","title":"Observability"},{"content":" Observability Nedir? #(Sistem GÃ¶zlemlenebilirliÄŸi)\nAll truths are easy to understand once they are discovered; the point is to discover them.\nâ€” Galileo Galilei\nBÃ¼tÃ¼n hakikatler keÅŸfedilince kolayca anlaÅŸÄ±lÄ±r; Ã¶nemli olan onlarÄ± keÅŸfetmektir.\nTanÄ±m: Observability, uygulamalarÄ±n canlÄ± ortamda bile iÃ§ durumlarÄ±nÄ± dÄ±ÅŸa vuran veriler Ã¼reterek izlenebilmesini saÄŸlayan bir yaklaÅŸÄ±mdÄ±r. AynÄ± zamanda bir sistemin iÃ§ durumunu dÄ±ÅŸ gÃ¶zlemlerle anlama yeteneÄŸini ifade eder ve daÄŸÄ±tÄ±k sistemlerde sistemin performansÄ±nÄ± izlemek ve hatalarÄ± tespit etmek iÃ§in kullanÄ±lÄ±r.\nNeden Ã–nemli?: IDE\u0026rsquo;de lokal olarak debug yapmak kolay. Ancak canlÄ±da bir sorun yaÅŸandÄ±ÄŸÄ±nda sistemi gÃ¶zlemleyebilmek iÃ§in bazÄ± verileri aktif olarak toplamamÄ±z gerekir.\nObservability\u0026rsquo;nin 3 Temel Veri Tipi # Log:\nSistemde meydana gelen olaylarÄ±n kaydÄ±dÄ±r ve detaylÄ± analiz yapma imkanÄ± sunar.\nUygulamanÄ±n zaman bilgisini (timestamp), mesajÄ±, sÄ±nÄ±f/metot bilgilerini ve formatlanmÄ±ÅŸ metinleri iÃ§erir.\nHer yere log atmak sakÄ±ncalÄ± olabilir, Ã§Ã¼nkÃ¼ sistemde yÃ¼k oluÅŸturabilir.\nMetrics:\nYÃ¼kÃ¼ en hafif olan, sistem performansÄ±nÄ± gÃ¶steren sayÄ±sal veriler saÄŸlar. (Ã¶r. CPU kullanÄ±mÄ±, kuyruktaki istek sayÄ±sÄ±, hata sayÄ±sÄ±).\nUygulamadan veya container/servis mesh gibi katmanlardan toplanabilir.\nTracing:\nÄ°ÅŸlemlerin daÄŸÄ±tÄ±k sistemlerde nasÄ±l ilerlediÄŸini izler. Ã–zellikle mikroservisler arasÄ± isteklerin nasÄ±l geÃ§tiÄŸini takip eder.\nTrace Data: BaÅŸlangÄ±Ã§tan bitiÅŸine kadar bir operasyonu (transaction) uÃ§tan uca izlemek iÃ§in oluÅŸturulur (Bu veride hangi iÅŸlemle devam etti, iÅŸlem ne kadar sÃ¼rdÃ¼ gibi veriler vardÄ±r.).\nGeniÅŸ Ã§aplÄ± (Ã¶r. bir HTTP requestâ€™in veritabanÄ± iÅŸlemlerine kadar takibi) sÃ¼reÃ§lerde gereklidir.\nHer yerde trace tutmak da kaynak tÃ¼ketimini artÄ±rÄ±r; ihtiyaca gÃ¶re konumlandÄ±rÄ±lmalÄ±dÄ±r.\nObservability\u0026rsquo;nin Ã–nemi # Hata AyÄ±klama: Performans ve hatalarÄ±n gerÃ§ek zamanlÄ± izlenmesi.\nProaktif Ä°zleme: SorunlarÄ± Ã¶nceden tespit etme ve Ã§Ã¶zÃ¼m Ã¼retme.\nSistem KararlÄ±lÄ±ÄŸÄ±: Daha dayanÄ±klÄ± ve performanslÄ± sistemler iÃ§in kritik.\n","date":null,"permalink":"/tr/presentations/distributed-system-series/observability/","section":"Presentations","summary":"Bu sunumda, modern daÄŸÄ±tÄ±k sistemlerde gÃ¶zlemlenebilirlik (observability) kavramÄ±nÄ± inceleyeceÄŸiz. YazÄ±lÄ±m sistemlerinde gÃ¶zlemlenebilirlik kavramÄ±nÄ±, log, trace ve metrics gibi temel bileÅŸenleri ve OpenTelemetry gibi endÃ¼stri standartlarÄ±nÄ± ele alarak, sistemlerin performansÄ±nÄ± nasÄ±l izleyebileceÄŸimizi ve hatalarÄ± nasÄ±l tespit edebileceÄŸimizi Ã¶ÄŸreneceÄŸiz.","title":"Observability ve OpenTelemetry Nedir?"},{"content":"","date":null,"permalink":"/tr/topics/opentelemetry/","section":"Topics","summary":"","title":"OpenTelemetry"},{"content":"","date":null,"permalink":"/tr/presentations/","section":"Presentations","summary":"","title":"Presentations"},{"content":"","date":null,"permalink":"/tr/topics/","section":"Topics","summary":"","title":"Topics"},{"content":"","date":null,"permalink":"/tr/topics/tracing/","section":"Topics","summary":"","title":"Tracing"},{"content":"","date":null,"permalink":"/tr/tags/acid/","section":"Tags","summary":"","title":"ACID"},{"content":"","date":null,"permalink":"/tr/tags/base/","section":"Tags","summary":"","title":"BASE"},{"content":"","date":null,"permalink":"/tr/tags/b%C3%BCy%C3%BCk-veri/","section":"Tags","summary":"","title":"BÃ¼yÃ¼k Veri"},{"content":" Bu yazÄ± serimizde, BÃ¼yÃ¼k Veri (Big Data) kavramÄ±nÄ±, temel bileÅŸenlerini ve teknolojilerini ele alÄ±yoruz. Hadoop, Spark ve NoSQL gibi araÃ§larÄ±n bu alandaki rolÃ¼nÃ¼ aÃ§Ä±klayarak, futbol sektÃ¶rÃ¼ gibi Ã¶rneklerle kullanÄ±m alanlarÄ±na deÄŸiniyoruz. ","date":null,"permalink":"/tr/series/big-data/","section":"Series","summary":"Bu yazÄ± serimizde, BÃ¼yÃ¼k Veri (Big Data) kavramÄ±nÄ±, temel bileÅŸenlerini ve teknolojilerini ele alÄ±yoruz. Hadoop, Spark ve NoSQL gibi araÃ§larÄ±n bu alandaki rolÃ¼nÃ¼ aÃ§Ä±klayarak, futbol sektÃ¶rÃ¼ gibi Ã¶rneklerle kullanÄ±m alanlarÄ±na deÄŸiniyoruz.","title":"BÃ¼yÃ¼k Veri (Big Data) Nedir?"},{"content":"","date":null,"permalink":"/tr/tags/cap-teoremi/","section":"Tags","summary":"","title":"CAP Teoremi"},{"content":"","date":null,"permalink":"/tr/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tr/tags/index/","section":"Tags","summary":"","title":"Index"},{"content":"","date":null,"permalink":"/tr/tags/nosql/","section":"Tags","summary":"","title":"NoSQL"},{"content":"","date":null,"permalink":"/tr/series/","section":"Series","summary":"","title":"Series"},{"content":"NoSQL veritabanlarÄ±, gÃ¼nÃ¼mÃ¼zÃ¼n bÃ¼yÃ¼k veri ve modern uygulama ihtiyaÃ§larÄ±nÄ± karÅŸÄ±lamak iÃ§in geleneksel iliÅŸkisel veritabanlarÄ±ndan farklÄ± bir yaklaÅŸÄ±m sunar. Bu yazÄ±mÄ±zda, SQL ve NoSQL veritabanlarÄ± arasÄ±ndaki temel farklara, ACID ve BASE modelleri arasÄ±ndaki ayrÄ±mlara, CAP Teoremi\u0026rsquo;nin bÃ¼yÃ¼k veri dÃ¼nyasÄ±ndaki Ã¶nemine ve NoSQL\u0026rsquo;in sunduÄŸu esnek mimariye odaklanacaÄŸÄ±z. AyrÄ±ca, farklÄ± NoSQL veritabanÄ± tÃ¼rlerini (dokÃ¼man, anahtar-deÄŸer, sÃ¼tunlu ve graf veritabanlarÄ± gibi) Ã¶rneklerle inceleyeceÄŸiz.1234\nSQL veritabanlarÄ±, Ã¶zellikle veritabanÄ± tutarlÄ±lÄ±ÄŸÄ± ve karmaÅŸÄ±k sorgular iÃ§in gÃ¼Ã§lÃ¼ bir yapÄ± sunarken, NoSQL veritabanlarÄ± daha esnek ve yatay Ã¶lÃ§eklenebilir Ã§Ã¶zÃ¼mler sunar. Bu yazÄ±da, her iki yaklaÅŸÄ±mÄ±n avantajlarÄ±nÄ± ve kullanÄ±m alanlarÄ±nÄ± karÅŸÄ±laÅŸtÄ±rarak, farklÄ± veri gereksinimlerine nasÄ±l hitap ettiklerini ele alacaÄŸÄ±z.\nBÃ¶yle daha kapsamlÄ± oldu! Uygun mudur?\nCAP Teoremi Nedir? #CAP Teoremi, Eric Brewer tarafÄ±ndan ortaya atÄ±lmÄ±ÅŸ bir teoridir ve daÄŸÄ±tÄ±k sistemlerin Ã¼Ã§ temel Ã¶zelliÄŸi aynÄ± anda saÄŸlayamayacaÄŸÄ±nÄ± ifade eder. Bu Ã¶zellikler ÅŸunlardÄ±r:\nConsistency (TutarlÄ±lÄ±k): Sistem Ã¼zerinde gerÃ§ekleÅŸtirilen her okuma iÅŸlemi, son yazma iÅŸleminden sonra gÃ¼ncellenmiÅŸ bir veri dÃ¶ndÃ¼rmelidir. Yani, tÃ¼m dÃ¼ÄŸÃ¼mler aynÄ± veriyi gÃ¶rmelidir. Availability (EriÅŸilebilirlik): Her okuma veya yazma isteÄŸi, bir hata durumu olmadÄ±kÃ§a, bir yanÄ±t almalÄ±dÄ±r. Sistem sÃ¼rekli eriÅŸilebilir durumda kalmalÄ±dÄ±r. Partition Tolerance (BÃ¶lÃ¼mleme ToleransÄ±): Sistem, aÄŸ bÃ¶lÃ¼nmeleri veya iletiÅŸim kesintileri gibi durumlarda bile Ã§alÄ±ÅŸmaya devam edebilmelidir. CAP Teoremi, Ã¼Ã§ Ã¶zelliÄŸin aynÄ± anda saÄŸlanamayacaÄŸÄ±nÄ± belirtir. Bu nedenle, NoSQL sistemlerinde genellikle iki Ã¶zellik arasÄ±nda bir denge kurulur:\nAP (Availability ve Partition Tolerance): TutarlÄ±lÄ±ktan Ã¶dÃ¼n verilerek sistem eriÅŸilebilirliÄŸi ve aÄŸ bÃ¶lÃ¼nmesine dayanÄ±klÄ±lÄ±k Ã¶nceliklendirilir. Ã–rnek: Cassandra, DynamoDB. CP (Consistency ve Partition Tolerance): EriÅŸilebilirlikten Ã¶dÃ¼n verilerek tutarlÄ±lÄ±k ve aÄŸ bÃ¶lÃ¼nmesine dayanÄ±klÄ±lÄ±k saÄŸlanÄ±r. Ã–rnek: MongoDB, HBase. CA (Consistency ve Availability): BÃ¶lÃ¼mleme toleransÄ± olmadan tutarlÄ±lÄ±k ve eriÅŸilebilirlik saÄŸlanabilir. Geleneksel tek dÃ¼ÄŸÃ¼mlÃ¼ SQL veritabanlarÄ±nda bu model uygulanabilirken, pratikte daÄŸÄ±tÄ±k sistemlerde aÄŸ bÃ¶lÃ¼nmeleri kaÃ§Ä±nÄ±lmaz olduÄŸundan bu yaklaÅŸÄ±m sÃ¼rdÃ¼rÃ¼lebilir deÄŸildir. DaÄŸÄ±tÄ±k SQL Ã§Ã¶zÃ¼mleri genellikle tutarlÄ±lÄ±ÄŸÄ± saÄŸlamak iÃ§in eriÅŸilebilirlikten Ã¶dÃ¼n verir (CP). Bu teorem, NoSQL veritabanlarÄ±nÄ±n hangi koÅŸullarda daha verimli olduÄŸunu anlamak iÃ§in kritik bir yol gÃ¶stericidir.\nBASE ve ACID Nedir? #BASE ve ACID, veritabanÄ± tasarÄ±mÄ±nda farklÄ± yaklaÅŸÄ±mlarÄ± ifade eden iki modeldir. Her iki model de veritabanlarÄ±nÄ±n gÃ¼venilirliÄŸi, performansÄ± ve Ã¶lÃ§eklenebilirliÄŸi Ã¼zerinde farklÄ± etkiler yaratÄ±r.\nACID #ACID ilkeleri, iliÅŸkisel veritabanlarÄ±nÄ±n saÄŸlam ve gÃ¼venilir bir ÅŸekilde Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlayan temel kurallardÄ±r:\nAtomicity (Atomiklik): Bir iÅŸlem ya tamamen gerÃ§ekleÅŸtirilir ya da hiÃ§ gerÃ§ekleÅŸtirilmez. Ä°ÅŸlemin bir parÃ§asÄ± baÅŸarÄ±sÄ±z olursa, iÅŸlem geri alÄ±nÄ±r ve veritabanÄ± Ã¶nceki durumuna dÃ¶ner. Consistency (TutarlÄ±lÄ±k): Her iÅŸlem, veritabanÄ±nÄ± bir tutarlÄ± durumdan diÄŸerine taÅŸÄ±r. Bu, iÅŸlem sonrasÄ± veritabanÄ±nÄ±n tanÄ±mlanmÄ±ÅŸ kurallara uygun bir duruma geÃ§mesini saÄŸlar. Isolation (Ä°zolasyon): AynÄ± anda birden fazla iÅŸlem yÃ¼rÃ¼tÃ¼ldÃ¼ÄŸÃ¼nde, iÅŸlemler birbirinden etkilenmez. Durability (KalÄ±cÄ±lÄ±k): Ä°ÅŸlem tamamlandÄ±ÄŸÄ±nda, sonuÃ§lar sistemde kalÄ±cÄ± olarak saklanÄ±r ve bir sistem hatasÄ± durumunda bile veri kaybÄ± yaÅŸanmaz. BASE #BASE yaklaÅŸÄ±mÄ±, NoSQL veritabanlarÄ±nÄ±n daha esnek ve Ã¶lÃ§eklenebilir bir ÅŸekilde Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlar:\nBasically Available (Temelde EriÅŸilebilir): Sistem her zaman bir yanÄ±t dÃ¶ndÃ¼rÃ¼r, ancak bu yanÄ±t her zaman gÃ¼ncel olmayabilir. Soft State (GeÃ§ici Durum): Veriler, iÅŸlem sÃ¼resince tutarlÄ± olmayabilir ve sistemin durumu zamanla deÄŸiÅŸebilir. Eventually Consistent (Sonunda TutarlÄ±): Sistem, belirli bir sÃ¼re iÃ§inde tutarlÄ± bir duruma ulaÅŸÄ±r. Verilerin anlÄ±k tutarlÄ±lÄ±ÄŸÄ± yerine sonunda tutarlÄ±lÄ±k saÄŸlanÄ±r. BASE modeli, Ã¶zellikle bÃ¼yÃ¼k Ã¶lÃ§ekli, daÄŸÄ±tÄ±k ve dinamik veri gereksinimlerinde tercih edilir. Ã–rneÄŸin, bir sosyal medya platformunda kullanÄ±cÄ±nÄ±n gÃ¶nderilerini anlÄ±k olarak gÃ¶rmemesi bÃ¼yÃ¼k bir sorun teÅŸkil etmez, ancak uzun vadede bu verilerin tutarlÄ± hale gelmesi gerekir.\nACID Prensiplerine Bir Ã–rnek: Banka HesaplarÄ± #Ahmet, aynÄ± banka hesabÄ±na baÄŸlÄ± iki farklÄ± banka kartÄ±na sahiptir. Bir gÃ¼n acil nakit ihtiyacÄ± olur ve hem kendisi hem de kardeÅŸi, farklÄ± ATM\u0026rsquo;lerden aynÄ± anda para Ã§ekmeye karar verir. Ahmet, ilk ATM\u0026rsquo;den 500 TL, kardeÅŸi ise ikinci ATM\u0026rsquo;den 400 TL Ã§ekmeye Ã§alÄ±ÅŸÄ±r.\nEÄŸer veritabanÄ± ACID prensiplerine uygun Ã§alÄ±ÅŸmasaydÄ±, bu iÅŸlemler birbiriyle uyumsuz ÅŸekilde yÃ¼rÃ¼tÃ¼lÃ¼rdÃ¼. Ã–rneÄŸin, hesapta yalnÄ±zca 700 TL varsa ve her iki iÅŸlem aynÄ± anda gerÃ§ekleÅŸirse, veritabanÄ± bu Ã§ekimlerden yalnÄ±zca birini kaydeder veya hatalÄ± bir bakiye gÃ¶sterirdi. Ahmetâ€™in 500 TL Ã§ektiÄŸi iÅŸlem kaydedilmiÅŸ gibi gÃ¶rÃ¼nÃ¼rken, kardeÅŸinin Ã§ektiÄŸi 400 TL iÅŸlem de gerÃ§ekleÅŸmiÅŸ olabilir ve toplamda 900 TL Ã§ekilmesine raÄŸmen hesapta hala 200 TL varmÄ±ÅŸ gibi gÃ¶rÃ¼nebilirdi. Bu, banka sisteminin tutarsÄ±zlÄ±k yaÅŸamasÄ±na ve mÃ¼ÅŸterilerin yanlÄ±ÅŸ bilgiye ulaÅŸmasÄ±na neden olurdu.\nACID prensipleri sayesinde bu durumun Ã¶nÃ¼ne geÃ§ilir. VeritabanÄ± iÅŸlemleri bir bÃ¼tÃ¼n olarak ele alÄ±r ve bir iÅŸlem tamamlanmadan diÄŸerine izin vermez. BÃ¶ylece, hesap bakiyesi her zaman doÄŸru ve tutarlÄ± bir ÅŸekilde yansÄ±tÄ±lÄ±r. Bu prensip, Ã¶zellikle finansal iÅŸlemler gibi kritik sÃ¼reÃ§lerde bÃ¼yÃ¼k Ã¶nem taÅŸÄ±r. BASE Prensiplerine Bir Ã–rnek: Sosyal Medya #Ã–te yandan, BASE prensipleri farklÄ± bir yaklaÅŸÄ±mÄ± benimser ve genellikle sosyal medya platformlarÄ±nda karÅŸÄ±mÄ±za Ã§Ä±kar. Ã–rneÄŸin, bir Ã¼nlÃ¼ Instagramâ€™da bir paylaÅŸÄ±m yaptÄ±ÄŸÄ±nda, gÃ¶nderinin altÄ±nda beÄŸeni sayÄ±sÄ±nÄ±n tam olarak 1.101.000 ya da sadece 1.1 milyon olarak gÃ¶rÃ¼nmesi pek Ã¶nemli deÄŸildir.\nKullanÄ±cÄ±lar iÃ§in Ã¶nemli olan, bu gÃ¶nderinin milyonlarca kiÅŸi tarafÄ±ndan beÄŸenildiÄŸinin anlaÅŸÄ±lmasÄ±dÄ±r; beÄŸeni sayÄ±sÄ±nÄ±n kesinliÄŸi anlÄ±k olarak kritik deÄŸildir. Bu yÃ¼zden, BASE prensiplerini izleyen sistemler, beÄŸeni sayÄ±sÄ±nÄ± zamanla gÃ¼nceller ve sÃ¼reÃ§ sonunda tutarlÄ± bir hale getirir. Bu sayede sistem, yÃ¼ksek Ã¶lÃ§eklenebilirliÄŸi koruyarak kullanÄ±cÄ± deneyimini hÄ±zlÄ± bir ÅŸekilde sunar.\nBu iki senaryo, ACID ve BASE arasÄ±nda yapÄ±lan temel tercihlerin, farklÄ± kullanÄ±m alanlarÄ± iÃ§in neden Ã¶nemli olduÄŸunu anlamamÄ±zÄ± saÄŸlar. Kimi zaman kesinlik ve gÃ¼venilirlik (ACID), kimi zaman da Ã¶lÃ§eklenebilirlik ve esneklik (BASE) Ã¶n planda olmalÄ±dÄ±r. DoÄŸru VeritabanÄ± SeÃ§iminin Ã–nemi: GerÃ§ek Bir Olay #Bu hikaye, adÄ±nÄ± paylaÅŸmak istemediÄŸim eski bir yazÄ±lÄ±mcÄ± arkadaÅŸÄ±mÄ±n deneyimlerinden geliyor. Bu arkadaÅŸÄ±m, iyi bir mÃ¼ÅŸteri kitlesi olan bir e-ticaret sitesi iÃ§in MongoDB kullanarak bir otomasyon sistemi geliÅŸtirdi. Ancak sistem, bir dÃ¶nem yoÄŸun trafik aldÄ±ÄŸÄ±nda, BASE modelinin \u0026ldquo;Eventually Consistent\u0026rdquo; Ã¶zelliÄŸi nedeniyle veritabanÄ±na hatalÄ± veriler yazdÄ±. Bunun sonucunda firma, stokta olmayan Ã¼rÃ¼nleri satmaya devam etti ve farkÄ±nda olmadan binlerce lira zarara uÄŸradÄ±.\nBu olay, veritabanÄ± seÃ§imi ve yapÄ±landÄ±rmasÄ±nÄ±n yalnÄ±zca bir teknoloji kararÄ± olmadÄ±ÄŸÄ±nÄ±, aynÄ± zamanda iÅŸ sÃ¼reÃ§lerini doÄŸrudan etkileyen kritik bir tercih olduÄŸunu gÃ¶steriyor. Ã–zellikle tutarlÄ±lÄ±ÄŸÄ±n Ã¶ncelikli olduÄŸu sistemlerde, ihtiyaÃ§ analizi ve doÄŸru yapÄ±landÄ±rma hayati Ã¶nem taÅŸÄ±r.\nNoSQL VeritabanlarÄ±nÄ±n GeliÅŸimi ve BÃ¼yÃ¼k Veriyle Ä°liÅŸkisi #NoSQL veritabanlarÄ±nÄ±n popÃ¼lerliÄŸi, Ã¶zellikle bÃ¼yÃ¼k veri ve daÄŸÄ±tÄ±k sistemlerin ortaya Ã§Ä±kmasÄ±yla birlikte hÄ±zla artmÄ±ÅŸtÄ±r. Geleneksel iliÅŸkisel veritabanlarÄ± (SQL), yÃ¼ksek hacimli, hÄ±zlÄ± bÃ¼yÃ¼yen ve Ã§eÅŸitli veri tÃ¼rlerini iÅŸlemek iÃ§in yeterince esnek deÄŸildir. NoSQL veritabanlarÄ± bu boÅŸluÄŸu doldurur ve aÅŸaÄŸÄ±daki avantajlarÄ± saÄŸlar:\nYatay Ã–lÃ§eklenebilirlik: VeritabanÄ± sistemi, donanÄ±m kapasitesini artÄ±rmak yerine yeni dÃ¼ÄŸÃ¼mler eklenerek kolayca geniÅŸletilebilir. Dinamik Åema: YapÄ±landÄ±rÄ±lmamÄ±ÅŸ veya yarÄ± yapÄ±landÄ±rÄ±lmÄ±ÅŸ verilerle Ã§alÄ±ÅŸmak iÃ§in daha uygundur. Performans: HÄ±zlÄ± sorgulama ve dÃ¼ÅŸÃ¼k gecikme sÃ¼releri sunar. Ã‡eÅŸitlilik: FarklÄ± kullanÄ±m senaryolarÄ±na uygun Ã§eÅŸitli NoSQL tÃ¼rleri bulunmaktadÄ±r. BÃ¼yÃ¼k Veri Ã‡Ã¶zÃ¼mleri ile Entegrasyon: NoSQL sistemleri, genellikle bÃ¼yÃ¼k veri iÅŸleme iÃ§in kullanÄ±lan Apache Hadoop gibi platformlarla kolayca entegre olabilir. Hadoopâ€™un HDFS (Hadoop DaÄŸÄ±tÄ±k Dosya Sistemi) ve MapReduce teknolojileri, bÃ¼yÃ¼k veri kÃ¼melerinin iÅŸlenmesinde Ã¶nemli bir rol oynar. BÃ¼yÃ¼k veri, verinin hacmi, Ã§eÅŸitliliÄŸi ve hÄ±zÄ± (3V: Volume, Variety, Velocity) ile karakterize edilir. Bu tÃ¼r verilerle baÅŸa Ã§Ä±kmak iÃ§in NoSQL veritabanlarÄ± ve Hadoop gibi bÃ¼yÃ¼k veri teknolojileri daha iyi bir Ã§Ã¶zÃ¼m sunar.\nNoSQL VeritabanÄ± TÃ¼rleri ve KullanÄ±m AlanlarÄ± #1. DokÃ¼man VeritabanlarÄ± # Ã–zellikleri: Veriler JSON, BSON veya XML formatÄ±nda saklanÄ±r. Belge odaklÄ± yapÄ±, esnek veri modellemesi saÄŸlar. KullanÄ±m AlanlarÄ±: Ä°Ã§erik yÃ¶netim sistemleri, kataloglar. Ã–rnekler: MongoDB, Couchbase. 2. Anahtar-DeÄŸer VeritabanlarÄ± # Ã–zellikleri: Veriler, anahtar-deÄŸer Ã§iftleri olarak saklanÄ±r. Basit ama hÄ±zlÄ± bir eriÅŸim modeli sunar. KullanÄ±m AlanlarÄ±: Ã–nbellekleme, oturum yÃ¶netimi. Ã–rnekler: Redis, DynamoDB. 3. Graf VeritabanlarÄ± # Ã–zellikleri: DÃ¼ÄŸÃ¼mler ve kenarlarla, veriler arasÄ±ndaki iliÅŸkileri modellemek iÃ§in idealdir. KullanÄ±m AlanlarÄ±: Sosyal aÄŸlar, Ã¶neri sistemleri. Ã–rnekler: Neo4j. 4. Arama ve Analitik VeritabanlarÄ± # Ã–zellikleri: Veriler, tam metin arama, analiz ve filtreleme iÃ§in optimize edilir. Elasticsearch, daÄŸÄ±tÄ±k bir altyapÄ±da Ã¶lÃ§eklenebilir sorgular sunar. JSON formatÄ±nda veri saklar ve hÄ±zlÄ± arama iÃ§in ters indeksleme kullanÄ±r. KullanÄ±m AlanlarÄ±: Log analitiÄŸi, metin analitiÄŸi, Ã¶neri sistemleri, bÃ¼yÃ¼k veri ile gerÃ§ek zamanlÄ± analiz. Ã–rnekler: Elasticsearch, Apache Solr. 5. GeniÅŸ SÃ¼tunlu VeritabanlarÄ± # Ã–zellikleri: Veriler sÃ¼tun bazlÄ± olarak organize edilir. BÃ¼yÃ¼k veri analitiÄŸi iÃ§in optimize edilmiÅŸtir. KullanÄ±m AlanlarÄ±: IoT verileri, log analitiÄŸi, bÃ¼yÃ¼k veri analitiÄŸi. Ã–rnekler: Apache Cassandra, HBase (Hadoop ile birlikte Ã§alÄ±ÅŸÄ±r). HBase, Apache Hadoop ekosisteminin bir parÃ§asÄ± olup, bÃ¼yÃ¼k Ã¶lÃ§ekli veri kÃ¼melerini iÅŸlemeye olanak saÄŸlar. HDFS ile birlikte Ã§alÄ±ÅŸarak verilerin daÄŸÄ±tÄ±k bir ÅŸekilde saklanmasÄ±nÄ± ve sorgulanmasÄ±nÄ± saÄŸlar. Ã–zellikle bÃ¼yÃ¼k veri analitiÄŸi ve gerÃ§ek zamanlÄ± uygulamalar iÃ§in ideal bir Ã§Ã¶zÃ¼m sunar.\n6. Zaman Serisi VeritabanlarÄ± # Ã–zellikleri: Zaman damgasÄ±yla iliÅŸkili veriler iÃ§in Ã¶zelleÅŸmiÅŸtir. KullanÄ±m AlanlarÄ±: SensÃ¶r verileri, IoT. Ã–rnekler: InfluxDB, TimescaleDB. Geleneksel SQL ve NoSQL Sistemlerinin KarÅŸÄ±laÅŸtÄ±rÄ±lmasÄ± # Ã–zellik SQL NoSQL Veri YapÄ±sÄ± Sabit ÅŸemalÄ± ve iliÅŸkisel. Esnek ÅŸemalÄ± ve iliÅŸkisel olmayan. Ã–lÃ§eklenebilirlik Dikey Ã¶lÃ§eklenebilir (daha gÃ¼Ã§lÃ¼ sunucular). Yatay Ã¶lÃ§eklenebilir (daha fazla dÃ¼ÄŸÃ¼m). Performans KarmaÅŸÄ±k sorgular iÃ§in optimize edilmiÅŸtir. BÃ¼yÃ¼k veri ve dÃ¼ÅŸÃ¼k gecikme iÃ§in uygundur. KullanÄ±m AlanlarÄ± Finansal iÅŸlemler, geleneksel iÅŸ uygulamalarÄ±. BÃ¼yÃ¼k veri, IoT, sosyal medya uygulamalarÄ±. SonuÃ§ #NoSQL veritabanlarÄ±, modern uygulamalarÄ±n gereksinimlerini karÅŸÄ±lamak adÄ±na esneklik ve Ã¶lÃ§eklenebilirlik sunar. BÃ¼yÃ¼k veri iÅŸleme, IoT ve gerÃ§ek zamanlÄ± uygulamalar gibi alanlarda saÄŸladÄ±ÄŸÄ± avantajlar ise bu teknolojiyi Ã¶ne Ã§Ä±karÄ±r. Ancak bir veritabanÄ± seÃ§meden Ã¶nce, BASE ve ACID modelleri arasÄ±ndaki farklarÄ± anlamak ve uygulamanÄ±n ihtiyaÃ§larÄ±nÄ± doÄŸru ÅŸekilde analiz etmek kritik Ã¶neme sahiptir.\nBu yazÄ±da, NoSQL sistemlerinin temel kavramlarÄ±na odaklandÄ±k. Gelecek yazÄ±larÄ±mÄ±zda ise Apache Hadoop, Spark, ve Kafka gibi veri akÄ±ÅŸÄ±nÄ±n yoÄŸun olduÄŸu sistemlerde izlenmesi gereken yollarÄ± detaylÄ±ca ele alacaÄŸÄ±z. Bir sonraki yazÄ±da gÃ¶rÃ¼ÅŸmek Ã¼zere! ğŸ˜Š\nWhatâ€™s the Difference Between an ACID and a BASE Database?\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nACID Model vs BASE Model For Database\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUdemy - Software Architecture \u0026amp; Technology of Large-Scale Systems\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChatGPT\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"27 Ocak 2025","permalink":"/tr/series/big-data/2-sql-nosql-nedir/","section":"Series","summary":"NoSQL veritabanlarÄ±, gÃ¼nÃ¼mÃ¼zÃ¼n bÃ¼yÃ¼k veri ve modern uygulama ihtiyaÃ§larÄ±nÄ± karÅŸÄ±lamak iÃ§in geleneksel iliÅŸkisel veritabanlarÄ±ndan farklÄ± bir yaklaÅŸÄ±m sunar. Bu yazÄ±mÄ±zda, SQL ve NoSQL veritabanlarÄ± arasÄ±ndaki temel farklara, ACID ve BASE modelleri arasÄ±ndaki ayrÄ±mlara, CAP Teoremi\u0026rsquo;nin bÃ¼yÃ¼k veri dÃ¼nyasÄ±ndaki Ã¶nemine ve NoSQL\u0026rsquo;in sunduÄŸu esnek mimariye odaklanacaÄŸÄ±z. AyrÄ±ca, farklÄ± NoSQL veritabanÄ± tÃ¼rlerini (dokÃ¼man, anahtar-deÄŸer, sÃ¼tunlu ve graf veritabanlarÄ± gibi) Ã¶rneklerle inceleyeceÄŸiz.1234\nSQL veritabanlarÄ±, Ã¶zellikle veritabanÄ± tutarlÄ±lÄ±ÄŸÄ± ve karmaÅŸÄ±k sorgular iÃ§in gÃ¼Ã§lÃ¼ bir yapÄ± sunarken, NoSQL veritabanlarÄ± daha esnek ve yatay Ã¶lÃ§eklenebilir Ã§Ã¶zÃ¼mler sunar.","title":"SQL, NoSQL ve BÃ¼yÃ¼k Veri: BASE, ACID ve CAP Teoremi"},{"content":"","date":null,"permalink":"/tr/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/tr/categories/teknoloji/","section":"Categories","summary":"","title":"Teknoloji"},{"content":"","date":null,"permalink":"/tr/categories/veritabanlar%C4%B1/","section":"Categories","summary":"","title":"VeritabanlarÄ±"},{"content":"","date":null,"permalink":"/tr/categories/big-data-serisi/","section":"Categories","summary":"","title":"Big-Data-Serisi"},{"content":"Selamlar,\nUzun zamandÄ±r Ã¼zerine araÅŸtÄ±rma yapmak istediÄŸim ve geÃ§miÅŸte biraz da olsa Ã¶ÄŸrenmeye Ã§alÄ±ÅŸtÄ±ÄŸÄ±m BÃ¼yÃ¼k Veri konusuna olan ilgim yeniden canlandÄ±. Bu kez, daha derinlemesine bir ÅŸekilde incelemek ve Ã¶ÄŸrendiklerimi bir yazÄ± serisiyle paylaÅŸmaya karar verdim. AyrÄ±ca fÄ±rsatÄ±m olursa bu seride bir de futbol verileri Ã¼zerinde (veya baÅŸka bir veri Ã¼zerinde) basit de olsa bir bÃ¼yÃ¼k veri Ã§alÄ±ÅŸmasÄ± yapmak istiyorum. Bu sÃ¼reÃ§te de birÃ§ok farklÄ± kaynaktan yararlanmaya Ã§alÄ±ÅŸÄ±yorum. 12345\nPeki o halde baÅŸlayalÄ±m, nedir bu BÃ¼yÃ¼k Veri (Big Data)? GÃ¼nÃ¼mÃ¼zÃ¼n dijital dÃ¼nyasÄ±nda bÃ¼yÃ¼k veri, iÅŸletmeler ve organizasyonlar iÃ§in vazgeÃ§ilmez bir kaynak haline gelmiÅŸtir. Bu serinin ilk yazÄ±sÄ±nda, bÃ¼yÃ¼k verinin ne olduÄŸunu, temel bileÅŸenlerini, Hadoop, Spark ve NoSQL gibi teknolojilerin bu alandaki rollerini ve futbol sektÃ¶rÃ¼nde nasÄ±l uygulandÄ±klarÄ±nÄ± inceleyeceÄŸiz.\nVeriniz yoksa, sadece bir baÅŸka fikri olan insansÄ±nÄ±z.\nâ€” W. Edwards Deming\nVeri, yeni petrole benzer.\nâ€” Clive Humby\nKeyifli okumalar!\nBÃ¼yÃ¼k Veri (Big Data) Nedir? #BÃ¼yÃ¼k veri, geleneksel veri iÅŸleme yÃ¶ntemleriyle yÃ¶netilmesi ve analiz edilmesi zor olan, Ã§ok bÃ¼yÃ¼k hacimde ve Ã§eÅŸitli kaynaklardan gelen veri kÃ¼melerini ifade eder. BÃ¼yÃ¼k veri, genellikle 5V modeliyle aÃ§Ä±klanÄ±r:\nHacim (Volume): OluÅŸturulan veri miktarÄ±nÄ±n bÃ¼yÃ¼klÃ¼ÄŸÃ¼nÃ¼ ifade eder. Ã–rneÄŸin, futbol maÃ§larÄ±nda saniyede Ã¼retilen konum ve hareket verileri terabaytlarca bilgi oluÅŸturabilir. Ã‡eÅŸitlilik (Variety): Verinin farklÄ± format ve tÃ¼rlerde olmasÄ±dÄ±r; yapÄ±landÄ±rÄ±lmÄ±ÅŸ (oyuncu istatistikleri), yarÄ± yapÄ±landÄ±rÄ±lmÄ±ÅŸ (JSON maÃ§ raporlarÄ±) ve yapÄ±landÄ±rÄ±lmamÄ±ÅŸ (maÃ§ videolarÄ±) veri gibi. HÄ±z (Velocity): Verinin oluÅŸturulma ve iÅŸlenme hÄ±zÄ±nÄ± belirtir. Ã–rneÄŸin, bir futbol maÃ§Ä±nda sensÃ¶rlerden gelen veriler anlÄ±k olarak analiz edilebilir. DoÄŸruluk (Veracity): Verinin doÄŸruluÄŸu ve gÃ¼venilirliÄŸidir. MaÃ§ istatistiklerinin hatasÄ±z ve anlamlÄ± olmasÄ± iÃ§in veri kaynaklarÄ±nÄ±n doÄŸruluÄŸu Ã¶nemlidir. DeÄŸer (Value): Verinin organizasyonlara saÄŸladÄ±ÄŸÄ± faydadÄ±r. Ã–rneÄŸin, oyuncu performans analizinden elde edilen bilgiler, antrenman programlarÄ±nÄ±n optimize edilmesini saÄŸlar. KiÅŸisel yorumum #Ä°ncelediÄŸim kaynaklarda, 5V modelinin Ã¶zellikle ilk Ã¼Ã§ boyutu (Hacim, Ã‡eÅŸitlilik ve HÄ±z) Ã¼zerinde daha fazla duruluyor. Ancak bana gÃ¶re, son iki boyut olan DoÄŸruluk ve DeÄŸer, en az ilk Ã¼Ã§Ã¼ kadar Ã¶nemli.\nÃ–rneÄŸin, elimizde yalnÄ±zca bir ÅŸirkete ait on yÄ±llÄ±k bir veri olduÄŸunu dÃ¼ÅŸÃ¼nelim. Bu veriler satÄ±ÅŸ ve yatÄ±rÄ±mlarÄ± iÃ§eriyor olsun. EÄŸer bu verilerin iÃ§inde yalnÄ±zca ÅŸirket ismi gibi doÄŸrudan anlam ifade etmeyen bilgiler varsa, bunlar bizim iÃ§in pek bir deÄŸer taÅŸÄ±maz; aksine, gereksiz bir hesaplama maliyeti oluÅŸturur. Ancak, bu verilere ek olarak ÅŸirketin o yÄ±l iÃ§erisindeki misyonu ve hedefleri gibi bilgiler de kayÄ±t altÄ±na alÄ±nmÄ±ÅŸsa, bu veriler satÄ±ÅŸlar Ã¼zerindeki etkileri analiz etmemizi saÄŸlar. BÃ¶ylece, elde edilen veriler daha anlamlÄ± hale gelir ve Ã§Ä±ktÄ±larÄ±mÄ±z daha verimli olur.\nBu nedenle, verilerimizin yalnÄ±zca hacmi ve Ã§eÅŸitliliÄŸi deÄŸil, aynÄ± zamanda doÄŸruluÄŸu ve sunduÄŸu deÄŸer de bÃ¼yÃ¼k veri analizinde kritik Ã¶neme sahiptir.\nHadoop Nedir? #Hadoop, bÃ¼yÃ¼k veri iÅŸleme iÃ§in kullanÄ±lan aÃ§Ä±k kaynaklÄ± bir framework\u0026rsquo;tÃ¼r. Apache VakfÄ± tarafÄ±ndan geliÅŸtirilen bu sistem, Ã§ok bÃ¼yÃ¼k veri kÃ¼melerini daÄŸÄ±tÄ±k bir ortamda depolamak ve iÅŸlemek iÃ§in tasarlanmÄ±ÅŸtÄ±r 6. Hadoop\u0026rsquo;un temel bileÅŸenleri ÅŸunlardÄ±r:\nHDFS (Hadoop Distributed File System): BÃ¼yÃ¼k veriyi daÄŸÄ±tÄ±k bir ÅŸekilde saklar. MapReduce: BÃ¼yÃ¼k veri setlerini iÅŸlemeye yÃ¶nelik bir programlama modeli. YARN (Yet Another Resource Negotiator): Kaynak yÃ¶netimini ve iÅŸ planlamasÄ±nÄ± saÄŸlar. Hadoop, futbol gibi veri yoÄŸun sektÃ¶rlerde bÃ¼yÃ¼k maÃ§ istatistiklerini saklamak ve analiz etmek iÃ§in kullanÄ±labilir. Bu kavramlara daha sonraki yazÄ±larÄ±mÄ±zda ayrÄ±ntÄ±lÄ± deÄŸineceÄŸiz.\nSpark Nedir? #Apache Spark, bÃ¼yÃ¼k veri iÅŸleme iÃ§in kullanÄ±lan hÄ±zlÄ± bir veri analitik motorudur. Hadoopâ€™a benzer ÅŸekilde daÄŸÄ±tÄ±k veri iÅŸlemeye odaklanÄ±r ancak Spark, Ã¶zellikle hafÄ±zada veri iÅŸleme (in-memory processing) yeteneÄŸiyle Ã¶ne Ã§Ä±kar 7.\nHÄ±zlÄ± Ä°ÅŸleme: Spark, veriyi bellekte iÅŸlediÄŸi iÃ§in analizlerde 100 kata kadar hÄ±z artÄ±ÅŸÄ± saÄŸlar. Esneklik: SQL, veri akÄ±ÅŸÄ± (streaming) ve makine Ã¶ÄŸrenimi gibi farklÄ± gÃ¶revleri destekler. KullanÄ±m AlanlarÄ±: GerÃ§ek zamanlÄ± veri analizi, futbol maÃ§larÄ±nda akÄ±ÅŸ verilerinin anlÄ±k deÄŸerlendirilmesi gibi. NoSQL Nedir? #NoSQL (Not Only SQL), yapÄ±landÄ±rÄ±lmamÄ±ÅŸ veya yarÄ± yapÄ±landÄ±rÄ±lmÄ±ÅŸ verilerin saklanmasÄ± ve iÅŸlenmesi iÃ§in tasarlanmÄ±ÅŸ bir veritabanÄ± tÃ¼rÃ¼dÃ¼r 8. Ã–rnek tÃ¼rler:\nDokÃ¼man TabanlÄ± VeritabanlarÄ±: JSON veya BSON formatÄ±nda verileri iÅŸler. Ã–rneÄŸin, MongoDB. Anahtar-DeÄŸer DepolarÄ±: Veriler anahtar-deÄŸer Ã§iftleri olarak saklanÄ±r. Ã–rneÄŸin, Redis. Graf VeritabanlarÄ±: Oyuncular arasÄ±ndaki baÄŸlantÄ±larÄ± analiz etmek iÃ§in kullanÄ±labilir. Ã–rneÄŸin, Neo4j. NoSQL, futbol maÃ§larÄ±nda Ã¼retilen bÃ¼yÃ¼k veri setlerini hÄ±zlÄ±ca sorgulamak ve analiz etmek iÃ§in ideal bir Ã§Ã¶zÃ¼m sunar.\nFutbol SektÃ¶rÃ¼nde BÃ¼yÃ¼k Veri UygulamalarÄ± #BÃ¼yÃ¼k veri, futbol sektÃ¶rÃ¼nde geniÅŸ bir uygulama alanÄ± bulmuÅŸtur:\nOyuncu Performans Analizi: SensÃ¶rler ve kameralarla toplanan veriler, oyuncularÄ±n hÄ±zÄ±nÄ±, dayanÄ±klÄ±lÄ±ÄŸÄ±nÄ± ve taktik uyumunu Ã¶lÃ§er. Taktiksel Analiz: Rakip takÄ±mlarÄ±n oyun dÃ¼zenleri, bÃ¼yÃ¼k veri analitiÄŸi ile incelenir ve taktik geliÅŸtirilir. Taraftar Deneyimi: TaraftarlarÄ±n sosyal medya etkileÅŸimleri analiz edilerek kiÅŸiselleÅŸtirilmiÅŸ kampanyalar oluÅŸturulur. MaÃ§ Ä°statistikleri: GerÃ§ek zamanlÄ± analizlerle maÃ§ boyunca taktiksel deÄŸiÅŸikliklere olanak tanÄ±r. Ã–rneÄŸin, Spark ve NoSQL veritabanlarÄ±, bir futbol maÃ§Ä±nda saniyede Ã¼retilen milyonlarca veri noktasÄ±nÄ± iÅŸleyerek antrenÃ¶rlere gerÃ§ek zamanlÄ± raporlar sunabilir.\nBÃ¼yÃ¼k Veri (Big Data) alanÄ±nda uzmanlaÅŸmÄ±ÅŸ profesyonellere olan talep, gÃ¼nÃ¼mÃ¼z iÅŸ dÃ¼nyasÄ±nda hÄ±zla artmaktadÄ±r. Veri analistleri, veri mÃ¼hendisleri ve veri bilimcileri gibi uzmanlar, ÅŸirketlerin stratejik kararlar almasÄ±na, operasyonel verimliliklerini artÄ±rmasÄ±na ve mÃ¼ÅŸteri deneyimlerini iyileÅŸtirmesine yardÄ±mcÄ± olmaktadÄ±r. Ã–zellikle teknoloji, finans, saÄŸlÄ±k ve perakende sektÃ¶rlerinde bÃ¼yÃ¼k veri uzmanlarÄ±na olan ihtiyaÃ§ belirgin bir ÅŸekilde artmaktadÄ±r.\nTÃ¼rkiye\u0026rsquo;de de bÃ¼yÃ¼k veri alanÄ±nda uzmanlaÅŸmÄ±ÅŸ profesyonellere yÃ¶nelik iÅŸ ilanlarÄ± bulunmaktadÄ±r. Ã–rneÄŸin, Veri Analiz UzmanÄ± pozisyonlarÄ±, farklÄ± sektÃ¶rlerde faaliyet gÃ¶steren firmalar tarafÄ±ndan sÄ±kÃ§a aranmaktadÄ±r.\nBÃ¼yÃ¼k Veri uzmanlarÄ±, veri analitiÄŸi, makine Ã¶ÄŸrenimi ve yapay zeka gibi alanlarda derinlemesine bilgi ve deneyime sahip olmalÄ±dÄ±r. Bu uzmanlÄ±k, onlara yÃ¼ksek maaÅŸlar ve hÄ±zlÄ± kariyer ilerlemesi gibi avantajlar sunmaktadÄ±r.\nFutbol kulÃ¼pleri de bÃ¼yÃ¼k veri mÃ¼hendislerine ihtiyaÃ§ duymaktadÄ±r. Ã–rneÄŸin, Manchester United ve Liverpool gibi dev futbol kulÃ¼pleri, veri mÃ¼hendisliÄŸi alanÄ±nda uzmanlaÅŸmÄ±ÅŸ profesyoneller aramaktadÄ±r. Bu tÃ¼r pozisyonlar, spor endÃ¼strisinde veri biliminin Ã¶nemini ve bÃ¼yÃ¼klÃ¼ÄŸÃ¼nÃ¼ gÃ¶stermektedir. 910\nLinkedIn\u0026rsquo;de Daha Ã–nceden PaylaÅŸÄ±lmÄ±ÅŸ Bir Ä°ÅŸ Ä°lanÄ± SonuÃ§ #Bu yazÄ±da BÃ¼yÃ¼k Veri kavramÄ±nÄ±n temellerini ve ilgili teknolojilere dair genel bir giriÅŸ yaptÄ±m. Bir sonraki yazÄ±mda, SQL-NoSQL veritabanlarÄ±nÄ±n temellerine, BASE ve ACID modelleri arasÄ±ndaki farklara, CAP Teoremi\u0026rsquo;ne, bÃ¼yÃ¼k veriyle iliÅŸkisine ve NoSQL veritabanÄ± tÃ¼rlerine odaklanacaÄŸÄ±m.\nBir sonraki yazÄ±da gÃ¶rÃ¼ÅŸmek Ã¼zere! ğŸ˜Š\nUdemy - Yeni BaÅŸlayanlar iÃ§in Big Data: NoSQL \u0026amp; Spark \u0026amp; Hadoop\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUdemy - SÄ±fÄ±rdan Her YÃ¶nÃ¼yle Big Data ( BÃ¼yÃ¼k Veri ) EÄŸitimi\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUdemy - (50 Saat) Python A-Zâ„¢: Veri Bilimi ve Machine Learning\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUdemy - Software Architecture \u0026amp; Technology of Large-Scale Systems\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChatGPT\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nApache Software Foundation. Apache Hadoop Documentation. https://hadoop.apache.org\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nApache Software Foundation. Apache Spark Documentation. https://spark.apache.org\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMongoDB, Inc. MongoDB Official Website. https://www.mongodb.com\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLead Data Scientist Liverpool Careers\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nYouTube - Erden Timur tv100 CanlÄ± YayÄ±n\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"18 Ocak 2025","permalink":"/tr/series/big-data/1-big-data-nedir/","section":"Series","summary":"Bu yazÄ±mÄ±zda, BÃ¼yÃ¼k Veri (Big Data) kavramÄ±nÄ±, temel bileÅŸenlerini ve teknolojilerini ele alÄ±yoruz. Hadoop, Spark ve NoSQL gibi araÃ§larÄ±n bu alandaki rolÃ¼nÃ¼ aÃ§Ä±klayarak, futbol sektÃ¶rÃ¼ gibi Ã¶rneklerle kullanÄ±m alanlarÄ±na deÄŸiniyoruz.","title":"BÃ¼yÃ¼k Veri: Nedir, Teknolojileri"},{"content":"","date":null,"permalink":"/tr/tags/futbol/","section":"Tags","summary":"","title":"Futbol"},{"content":"","date":null,"permalink":"/tr/tags/hadoop/","section":"Tags","summary":"","title":"Hadoop"},{"content":"","date":null,"permalink":"/tr/tags/spark/","section":"Tags","summary":"","title":"Spark"},{"content":"","date":null,"permalink":"/tr/topics/chain-of-responsibility/","section":"Topics","summary":"","title":"Chain of Responsibility"},{"content":" Chain of Responsibility Nedir? #\nPhoto by Refactoring Guru # Chain of Responsibility\u0026rsquo;nin TanÄ±mÄ± #Chain of Responsibility, bir isteÄŸin, bir zincir ÅŸeklinde dÃ¼zenlenmiÅŸ iÅŸleyiciler arasÄ±nda dolaÅŸtÄ±rÄ±larak iÅŸlenmesini saÄŸlar. Her iÅŸleyici isteÄŸi iÅŸleyebilir veya bir sonraki iÅŸleyiciye iletebilir.\nChain of Responsibility\u0026rsquo;nin Temel BileÅŸenleri # Handler (Ä°ÅŸleyici): Ä°steÄŸi iÅŸleyen veya bir sonraki iÅŸleyiciye gÃ¶nderen temel bileÅŸen. Concrete Handler: Ä°steÄŸi belirli kriterlere gÃ¶re iÅŸleyen iÅŸleyici sÄ±nÄ±flarÄ±. Client: Ä°steÄŸi gÃ¶nderen bileÅŸen. Chain of Responsibility NasÄ±l Ã‡alÄ±ÅŸÄ±r? # Ä°stek GÃ¶nderme: MÃ¼ÅŸteri isteÄŸi bir iÅŸleyiciye iletir. Ä°ÅŸleme KontrolÃ¼: Ä°ÅŸleyici isteÄŸi iÅŸleyip iÅŸlemeyeceÄŸine karar verir. Zincirleme Ä°ÅŸleyiciler: Ä°ÅŸleyici isteÄŸi iÅŸleyemiyorsa bir sonraki iÅŸleyiciye iletir. SonuÃ§: Ä°stek iÅŸlenir veya tÃ¼m zincir dolaÅŸÄ±r. Chain of Responsibility Ã–rnek Kod (C#) #public abstract class Handler { protected Handler next; public void SetNext(Handler nextHandler) { this.next = nextHandler; } public abstract void HandleRequest(string request); } public class ConcreteHandlerA : Handler { public override void HandleRequest(string request) { if (request == \u0026#34;A\u0026#34;) { Console.WriteLine(\u0026#34;Handler A is processing the request.\u0026#34;); } else if (next != null) { next.HandleRequest(request); } } } public class ConcreteHandlerB : Handler { public override void HandleRequest(string request) { if (request == \u0026#34;B\u0026#34;) { Console.WriteLine(\u0026#34;Handler B is processing the request.\u0026#34;); } else if (next != null) { next.HandleRequest(request); } } } // KullanÄ±m: var handlerA = new ConcreteHandlerA(); var handlerB = new ConcreteHandlerB(); handlerA.SetNext(handlerB); handlerA.HandleRequest(\u0026#34;B\u0026#34;); Chain of Responsibility\u0026rsquo;nin AvantajlarÄ± # GevÅŸek BaÄŸlÄ±lÄ±k: Ä°steÄŸi gÃ¶nderen, hangi iÅŸleyicinin sorumlu olduÄŸunu bilmek zorunda deÄŸildir. GeniÅŸletilebilirlik: Yeni iÅŸleyiciler eklenebilir ve zincir kolayca yapÄ±landÄ±rÄ±labilir. Sorumluluk DaÄŸÄ±lÄ±mÄ±: YÃ¼k birden fazla iÅŸleyici arasÄ±nda daÄŸÄ±tÄ±labilir. Chain of Responsibility\u0026rsquo;nin DezavantajlarÄ± # Zincir KarmaÅŸÄ±klÄ±ÄŸÄ±: Uzun zincirlerde isteÄŸin iÅŸlenme sÃ¼resi uzayabilir. Ä°ÅŸlenmeyen Ä°stekler: HiÃ§bir iÅŸleyici isteÄŸi iÅŸleyemezse, sorun Ã§Ã¶zÃ¼lmemiÅŸ olabilir. Chain of Responsibility KullanÄ±m AlanlarÄ± # AlÄ±ÅŸveriÅŸ Siteleri Ä°ÅŸ KurallarÄ±: AlÄ±ÅŸveriÅŸ sitelerinde sepet gibi iÅŸ kollarÄ±nda iÅŸ kurallarÄ± Ã§ok fazla olabilir. Bunu daha okunabilir ve bakÄ±mÄ± kolay hale getirmek iÃ§in bu desen kullanÄ±labilir. Destek Hizmetleri: MÃ¼ÅŸteri ÅŸikayetlerinin kademeli olarak Ã§Ã¶zÃ¼lmesi. Ä°zin Sistemleri: Bir izin talebinin farklÄ± seviyelerde iÅŸlenmesi. Oyun GeliÅŸtirme: Oyunlarda olaylarÄ±n farklÄ± karakterler veya mekanlar tarafÄ±ndan iÅŸlenmesi. SonuÃ§ # Chain of Responsibility, esnek ve geniÅŸletilebilir bir Ã§Ã¶zÃ¼m sunar. Ä°ÅŸ akÄ±ÅŸÄ± kolayca yÃ¶netilebilir, ancak zincirin iyi yapÄ±landÄ±rÄ±lmasÄ± gerekir. Demo # DinlediÄŸiniz iÃ§in teÅŸekkÃ¼rler #Kaynaklar: Refactoring Guru\nÃ–rnekler Reposu: aimtune/design-patterns-examples\n","date":"7 Ekim 2024","permalink":"/tr/presentations/design-patterns-series/chain_of_responsibility/","section":"Presentations","summary":"Bu sunumda, Chain of Responsibility tasarÄ±m deseni ile isteklerin nasÄ±l iÅŸleyiciler arasÄ±nda dolaÅŸtÄ±rÄ±larak iÅŸlendiÄŸini inceleyeceÄŸiz.","title":"Chain of Responsibility"},{"content":"","date":null,"permalink":"/tr/topics/design-patterns/","section":"Topics","summary":"","title":"Design Patterns"},{"content":"","date":null,"permalink":"/tr/topics/handlers/","section":"Topics","summary":"","title":"Handlers"},{"content":"","date":null,"permalink":"/tr/topics/oop/","section":"Topics","summary":"","title":"OOP"},{"content":"","date":null,"permalink":"/tr/topics/software-design/","section":"Topics","summary":"","title":"Software Design"},{"content":"","date":null,"permalink":"/tr/topics/choreography/","section":"Topics","summary":"","title":"Choreography"},{"content":"","date":null,"permalink":"/tr/topics/event-driven-architecture/","section":"Topics","summary":"","title":"Event-Driven Architecture"},{"content":"","date":null,"permalink":"/tr/topics/fault-tolerance/","section":"Topics","summary":"","title":"Fault Tolerance"},{"content":"","date":null,"permalink":"/tr/topics/kubernetes/","section":"Topics","summary":"","title":"Kubernetes"},{"content":"","date":null,"permalink":"/tr/topics/mikroservisler/","section":"Topics","summary":"","title":"Mikroservisler"},{"content":"","date":null,"permalink":"/tr/topics/orchestration/","section":"Topics","summary":"","title":"Orchestration"},{"content":" Saga Pattern #\n(BaÄŸÄ±msÄ±z ve Hata ToleranslÄ± Ä°ÅŸ AkÄ±ÅŸÄ± YÃ¶netimi) Photo by Microservices Architecture Pattern - SAGA # Saga Pattern\u0026rsquo;e GiriÅŸ #Saga, mikroservis tabanlÄ± uygulamalarda uzun sÃ¼reli ve birden fazla adÄ±mdan oluÅŸan iÅŸlemleri yÃ¶netmek iÃ§in kullanÄ±lan bir iÅŸ akÄ±ÅŸÄ± yÃ¶netim desenidir.\nSaga\u0026rsquo;nÄ±n AmacÄ± ve FaydalarÄ± # Saga, daÄŸÄ±tÄ±k sistemlerde uzun sÃ¼reli iÅŸlemleri gÃ¼venli bir ÅŸekilde yÃ¶netmek iÃ§in kullanÄ±lÄ±r. Ä°ÅŸlemleri adÄ±mlara bÃ¶lerek hata durumunda her bir adÄ±mÄ±n telafi edilmesini saÄŸlar. Sistemin genel dayanÄ±klÄ±lÄ±ÄŸÄ±nÄ± artÄ±rÄ±r ve hata yÃ¶netimini daha yapÄ±landÄ±rÄ±lmÄ±ÅŸ bir ÅŸekilde ele alÄ±r. Saga Pattern\u0026rsquo;in Temel BileÅŸenleri # Choreography Orchestration Compensation Error Handling Error Handling (Hata YÃ¶netimi)\nHata yÃ¶netimi, Saga Choreography\u0026rsquo;de her adÄ±mÄ±n hata durumunda telafi iÅŸlemlerini tetiklemesiyle gerÃ§ekleÅŸtirilir. Merkezi bir kontrol olmadÄ±ÄŸÄ± iÃ§in servisler kendi hatalarÄ±nÄ± olay tabanlÄ± bir yaklaÅŸÄ±mla yÃ¶netir ve durumu geri alÄ±r.\nSaga Pattern\u0026rsquo;in Temel BileÅŸenleri # Event-Driven Communication Service Independence Real-Time Updates Distributed Transactions Event-Driven Communication (Olay TabanlÄ± Ä°letiÅŸim)\nServisler arasÄ±nda asenkron iletiÅŸim, olay tabanlÄ± bir yapÄ± ile saÄŸlanÄ±r. Her servis, bir iÅŸlemi tamamladÄ±ÄŸÄ±nda bir olay yayÄ±nlar ve bu olay, diÄŸer servisler tarafÄ±ndan dinlenerek iÅŸlemlerin tetiklenmesini saÄŸlar.\nService Independence (Servis BaÄŸÄ±msÄ±zlÄ±ÄŸÄ±)\nChoreography, her servisin kendi iÅŸ mantÄ±ÄŸÄ±nÄ± baÄŸÄ±msÄ±z olarak yÃ¶netmesini saÄŸlar. Bu yapÄ±, servislerin birbirinden izole olmasÄ±nÄ± ve kendi baÅŸlarÄ±na Ã§alÄ±ÅŸabilmelerini mÃ¼mkÃ¼n kÄ±lar, bÃ¶ylece sistemin esnekliÄŸi artar.\nReal-Time Updates (GerÃ§ek ZamanlÄ± GÃ¼ncellemeler)\nOlay tabanlÄ± iletiÅŸim sayesinde servisler gerÃ§ek zamanlÄ± olarak birbirleriyle etkileÅŸime geÃ§er. Bu sayede, sistemdeki gÃ¼ncellemeler anÄ±nda diÄŸer servisleri tetikler ve hÄ±zlÄ± tepki sÃ¼releri saÄŸlar.\nDistributed Transactions (DaÄŸÄ±tÄ±k Ä°ÅŸlemler)\nDaÄŸÄ±tÄ±k iÅŸlemler, Saga Pattern ile adÄ±mlara bÃ¶lÃ¼nerek yÃ¶netilir. Her bir iÅŸlem adÄ±mÄ± baÄŸÄ±msÄ±zdÄ±r ve hata durumunda telafi edici iÅŸlemlerle gÃ¼venilir bir ÅŸekilde geri alÄ±nabilir, bu da sistemin bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ korur.\nChoreography vs Orchestration #Choreography ve Orchestration, Saga Pattern\u0026rsquo;in iki ana uygulama yÃ¶ntemidir. Bu sunumda Ã¶zellikle Choreography Ã¼zerine odaklanacaÄŸÄ±z.\nChoreography ve Orchestration FarklarÄ± # Choreography: Servisler olaylar aracÄ±lÄ±ÄŸÄ±yla birbirleriyle konuÅŸur, merkezi bir kontrol yoktur. Orchestration: Merkezi bir kontrol birimi (orchestrator) tÃ¼m sÃ¼reci yÃ¶netir ve kontrol eder. Choreography YapÄ±sÄ±nÄ±n Ã–zellikleri # Olay TabanlÄ± Ä°letiÅŸim: Servisler arasÄ±nda asenkron olaylar yoluyla iletiÅŸim kurulur, bu da sistemin daha hÄ±zlÄ± tepki vermesini saÄŸlar. Servislerin BaÄŸÄ±msÄ±zlÄ±ÄŸÄ±: Her servis kendi sorumluluÄŸunda olan iÅŸi yapar ve diÄŸer servislerden baÄŸÄ±msÄ±z Ã§alÄ±ÅŸÄ±r. Bu, sistemin esnekliÄŸini ve Ã¶lÃ§eklenebilirliÄŸini artÄ±rÄ±r. Choreography YapÄ±sÄ±nÄ±n Ã–zellikleri # DaÄŸÄ±tÄ±k Mimari iÃ§in Uygunluk: Choreography, daÄŸÄ±tÄ±k sistemlerde merkezi bir yÃ¶netim olmadan iÅŸ akÄ±ÅŸlarÄ±nÄ± etkin bir ÅŸekilde yÃ¶netir. Servisler kendi iÅŸlemlerini yÃ¶netirken olay tabanlÄ± bir akÄ±ÅŸla ilerler. Choreography\u0026rsquo;nin AvantajlarÄ± # Merkezi kontrol birimi yoktur; servisler baÄŸÄ±msÄ±zdÄ±r. Olay tabanlÄ± iletiÅŸim, hÄ±zlÄ± ve gerÃ§ek zamanlÄ± gÃ¼ncellemeler saÄŸlar. Sistemin esnekliÄŸi ve Ã¶lÃ§eklenebilirliÄŸi yÃ¼ksektir. Choreography\u0026rsquo;nin DezavantajlarÄ± ve ZorluklarÄ± # Hata yÃ¶netimi karmaÅŸÄ±ktÄ±r ve telafi iÅŸlemleri zor olabilir. OlaylarÄ±n izlenmesi ve yÃ¶netimi zordur (event storming). Servisler arasÄ±nda beklenmeyen baÄŸÄ±mlÄ±lÄ±klar oluÅŸabilir. Compensation Ä°ÅŸlemleri (Compensable Transactions) # BaÅŸarÄ±sÄ±z adÄ±mlarÄ± geri alarak sistemin Ã¶nceki durumuna dÃ¶nmesini saÄŸlar. Telafi edici iÅŸlemler her adÄ±m iÃ§in ayrÄ± tanÄ±mlanÄ±r ve hata durumunda tetiklenir. Servisler baÄŸÄ±msÄ±z Ã§alÄ±ÅŸÄ±rken kendi telafi iÅŸlemlerini yÃ¶netir. Hata YÃ¶netimi # Hatalar olaylar aracÄ±lÄ±ÄŸÄ±yla yÃ¶netilir ve her adÄ±mda telafi iÅŸlemleri tetiklenir. Olay tabanlÄ± hata yÃ¶netimi, olaylarÄ±n doÄŸru izlenmesini ve uygun yanÄ±t verilmesini gerektirir. Ã–zellikle karmaÅŸÄ±k hata senaryolarÄ± iÃ§in dikkatli bir planlama ve gÃ¼Ã§lÃ¼ telafi iÅŸlemleri gereklidir. Demo # You found the speaker notes! DinlediÄŸiniz iÃ§in teÅŸekkÃ¼rler #Kaynaklar: A\u0026rsquo;dan Z\u0026rsquo;ye Mikroservis Mimarisi EÄŸitimi - 1. Etap - ChatGPT\nÃ–rnekler Reposu: aimtune/distributed-systems-design-patterns-examples\n","date":"3 EylÃ¼l 2024","permalink":"/tr/presentations/distributed-system-series/saga-pattern-choreography/","section":"Presentations","summary":"Bu sunumda modern mikroservis mimarileri iÃ§in gÃ¼Ã§lÃ¼ bir iÅŸ akÄ±ÅŸÄ± yÃ¶netimi deseni olan Saga\u0026rsquo;yÄ± keÅŸfedeceÄŸiz. Sunumda deÄŸinilecek Saga konularÄ±: Choreography (Koreografi), Orchestration (Orkestrasyon), Compensation (Telafi Ä°ÅŸlemleri), Error Handling (Hata YÃ¶netimi), Transaction Management (Ä°ÅŸlem YÃ¶netimi).","title":"Saga Choreography"},{"content":"","date":null,"permalink":"/tr/topics/saga-pattern/","section":"Topics","summary":"","title":"Saga Pattern"},{"content":"Elixir Nedir? #Elixir, fonksiyonel, eÅŸ zamanlÄ± (concurrent) ve daÄŸÄ±tÄ±k programlama (distributed programming) iÃ§in tasarlanmÄ±ÅŸ, dinamik ve gÃ¼Ã§lÃ¼ bir programlama dilidir. Elixir, Ã¶zellikle yÃ¼ksek performanslÄ±, Ã¶lÃ§eklenebilir (scalable) ve hata toleranslÄ± (fault tolerance) sistemler geliÅŸtirmek iÃ§in idealdir.1 2\nElixir, Erlang sanal makinesi (BEAM) Ã¼zerinde Ã§alÄ±ÅŸÄ±r ve bu sayede gÃ¼Ã§lÃ¼ concurrency (eÅŸzamanlÄ±lÄ±k) Ã¶zelliklerine sahiptir. Erlang (Ericsson Language), 1980\u0026rsquo;lerde Ericsson tarafÄ±ndan telekomÃ¼nikasyon sistemleri iÃ§in geliÅŸtirildi ve BEAM sanal makinesi, bu yÃ¼ksek talepli sistemlerin gereksinimlerini karÅŸÄ±lamak iÃ§in optimize edildi.\nErlang ve Elixir HelloWorld Ã–rnekleri #Erlang #-module(helloworld). -export([say_hello/0]). say_hello() -\u0026gt; io:format(\u0026#34;Hello, World!~n\u0026#34;). Elixir #defmodule HelloWorld do def say_hello do IO.puts(\u0026#34;Hello, World!\u0026#34;) end end HelloWorld.say_hello() Not: Elixir, aslÄ±nda HelloWorld Ã¶rneÄŸinde olduÄŸu gibi daha uzun deÄŸil, aksine daha kÄ±sa yazÄ±labiliyor ve okunabilirlik konusunda da daha iyi. Temel Ã–zellikler # Fonksiyonel Programlama: Elixir, fonksiyonel programlamayÄ± destekler ve immutable (deÄŸiÅŸemeyen) veri yapÄ±larÄ± ile Ã§alÄ±ÅŸÄ±r. Bu, daha gÃ¼venli ve Ã¶ngÃ¶rÃ¼lebilir kod yazmanÄ±zÄ± saÄŸlar. Ã–rneÄŸin aÅŸaÄŸÄ±da map, filter gibi fonksiyonlar zincir ÅŸeklinde birbirini pipe(|) iÅŸareti ile Ã§aÄŸÄ±rÄ±yolar ve her biri Ã§Ä±ktÄ±sÄ±nÄ± bir sonraki fonksiyona girdi olarak veriyor: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 defmodule MyList do def process_list(list) do list |\u0026gt; Enum.map(\u0026amp;(\u0026amp;1 + 1)) |\u0026gt; Enum.filter(\u0026amp;rem(\u0026amp;1, 2) == 0) |\u0026gt; Enum.map(\u0026amp;(\u0026amp;1 * \u0026amp;1)) |\u0026gt; Enum.sum() end end # KullanÄ±m list = [1, 2, 3, 4, 5] result = MyList.process_list(list) IO.puts(\u0026#34;SonuÃ§: #{result}\u0026#34;) EÅŸ ZamanlÄ± (Concurrent) ve DaÄŸÄ±tÄ±k Sistemler: Elixir, aynÄ± anda birÃ§ok iÅŸlemi (process) verimli bir ÅŸekilde yÃ¼rÃ¼tebilir ve daÄŸÄ±tÄ±k sistemlerde mÃ¼kemmel performans sergiler. Erlang VM (BEAM) Ã¼zerine inÅŸa edildiÄŸi iÃ§in bu Ã¶zellikleri doÄŸal olarak sunar. Erlang VM (BEAM): Elixir, Erlang sanal makinesi (BEAM) Ã¼zerinde Ã§alÄ±ÅŸÄ±r ve bu sayede Erlangâ€™Ä±n saÄŸlam ve hata toleransÄ± Ã¶zelliklerinden yararlanÄ±r. BEAM, hafif sÃ¼reÃ§leri (process) ve mesaj geÃ§iÅŸini (message passing) destekleyen bir yapÄ± sunar. Bu sÃ¼reÃ§ler, iÅŸletim sistemi iÅŸ parÃ§acÄ±klarÄ±ndan Ã§ok daha hafif olup, binlerce hatta milyonlarca sÃ¼recin aynÄ± anda Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ± mÃ¼mkÃ¼n kÄ±lar. Erlang Scheduler, bu hafif sÃ¼reÃ§leri etkin bir ÅŸekilde yÃ¶netir ve her bir CPU Ã§ekirdeÄŸi iÃ§in bir scheduler thread Ã§alÄ±ÅŸtÄ±rÄ±r. Scheduler, sÃ¼reÃ§lerin adil bir ÅŸekilde Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ± saÄŸlar ve yÃ¼ksek verimli bir yÃ¼k dengeleme mekanizmasÄ± sunar. Bu Ã¶zellikler sayesinde, Elixir ile yazÄ±lan uygulamalar yÃ¼ksek eÅŸzamanlÄ±lÄ±k ve dÃ¼ÅŸÃ¼k gecikme sÃ¼releriyle mÃ¼kemmel performans sergiler.\nPhoto by How to build fault-tolerant software systems Ãœretkenlik ve BakÄ±m KolaylÄ±ÄŸÄ±: Modern dil Ã¶zellikleri ve zengin standart kÃ¼tÃ¼phaneleri ile Elixir, geliÅŸtiricilerin Ã¼retkenliÄŸini artÄ±rÄ±r ve kodun bakÄ±mÄ±nÄ± kolaylaÅŸtÄ±rÄ±r. Hata ToleransÄ±: Elixir, hata yÃ¶netimi konusunda gÃ¼Ã§lÃ¼dÃ¼r ve sistemlerin kesintisiz Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlamak iÃ§in â€œlet it crashâ€3 felsefesini benimser bu da sistemlerin hata durumlarÄ±nda hÄ±zlÄ± bir ÅŸekilde toparlanmasÄ±nÄ± saÄŸlar. 4 Ã–lÃ§eklenebilirlik (Scalability): Elixir, yÃ¼ksek Ã¶lÃ§eklenebilirlik sunar ve aynÄ± anda milyonlarca iÅŸlemi yÃ¶netebilir. GÃ¼venilirlik (Reliability): Elixir, saÄŸlam yapÄ±sÄ± ve hata toleransÄ± ile gÃ¼venilir sistemler geliÅŸtirmeyi saÄŸlar. DaÄŸÄ±tÄ±k Sistemler (Distribution): Elixir, daÄŸÄ±tÄ±k sistemlerde mÃ¼kemmel performans sergiler ve kolayca Ã¶lÃ§eklendirilebilir. HÄ±zlÄ± YanÄ±t Verme (Responsiveness): Elixir, kullanÄ±cÄ±larÄ±nÄ±za anÄ±nda yanÄ±t verebilen hÄ±zlÄ± ve verimli sistemler oluÅŸturmanÄ±za imkan tanÄ±r. CanlÄ± GÃ¼ncellemeler (Live Update): Elixir, uygulamalarÄ±nÄ±zÄ± kesinti olmadan gÃ¼ncelleyebilmenizi (deployment) saÄŸlar. YÃ¼ksek EriÅŸilebilirlik (High Availability): Elixir, yÃ¼ksek eriÅŸilebilirlik gerektiren uygulamalarda mÃ¼kemmel performans sunar. OTP ve GenServer: Elixir, yÃ¼ksek performanslÄ±, daÄŸÄ±tÄ±k ve hata toleranslÄ± uygulamalar geliÅŸtirmek iÃ§in kullanÄ±lan OTP (Open Telecom Platform) adlÄ± bir kÃ¼tÃ¼phane ve araÃ§ seti ile birlikte gelir. OTP\u0026rsquo;nin temel yapÄ± taÅŸlarÄ±ndan biri olan GenServer, sÃ¼reÃ§lerin yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼ ve mesajlaÅŸmasÄ±nÄ± yÃ¶netir. GenServer, belirli iÅŸlevleri gerÃ§ekleÅŸtirmek ve durum bilgisi tutmak iÃ§in kullanÄ±lÄ±r, bu da karmaÅŸÄ±k iÅŸ mantÄ±klarÄ±nÄ±n kolayca yÃ¶netilmesini saÄŸlar. Hex Paket YÃ¶neticisi ve Mix: Hex, Elixir ve Erlang projeleri iÃ§in kullanÄ±lan bir paket yÃ¶neticisidir. Hex, baÄŸÄ±mlÄ±lÄ±klarÄ± yÃ¶netmeyi, paylaÅŸmayÄ± ve Elixir kÃ¼tÃ¼phanelerini kolayca yÃ¼klemeyi saÄŸlar. Mix ise Elixir projelerini oluÅŸturmak, derlemek, test etmek ve yÃ¶netmek iÃ§in kullanÄ±lan gÃ¼Ã§lÃ¼ bir araÃ§tÄ±r. Mix, baÄŸÄ±mlÄ±lÄ±k yÃ¶netimi, uygulama yapÄ±landÄ±rmasÄ± ve gÃ¶rev otomasyonu gibi iÅŸlevleri saÄŸlar. Makrolar: Makrolar, Elixir\u0026rsquo;de kodunuzu derleme zamanÄ±nda dÃ¶nÃ¼ÅŸtÃ¼rmenizi ve geniÅŸletmenizi saÄŸlayan gÃ¼Ã§lÃ¼ araÃ§lardÄ±r. Makrolar, kodunuzu daha dinamik ve esnek hale getirmenizi saÄŸlar. Elixir\u0026rsquo;de makrolar defmacro anahtar kelimesi ile tanÄ±mlanÄ±r. Ã–rneÄŸin aÅŸaÄŸÄ±daki Ã¶rnekte5 Ecto kÃ¼tÃ¼phanesiyle .NET\u0026rsquo;teki LINQ yapÄ±sÄ±na benzer bir sorgulama makrolar sayesinde yapÄ±labilmiÅŸ. 1 2 3 4 5 6 7 8 9 10 # Imports only from/2 of Ecto.Query import Ecto.Query, only: [from: 2] # Create a query query = from u in \u0026#34;users\u0026#34;, where: u.age \u0026gt; 18, select: u.name # Send the query to the repository Repo.all(query) KullanÄ±m AlanlarÄ± #Erlang, Ã¶zellikle telekomÃ¼nikasyon sektÃ¶rÃ¼nde yÃ¼ksek eriÅŸilebilirlik ve gÃ¼venilirlik gerektiren sistemlerde uzun yÄ±llardÄ±r kullanÄ±lmaktadÄ±r. Ericsson, WhatsApp, Facebook ve RabbitMQ gibi bÃ¼yÃ¼k ÅŸirketler, yÃ¼ksek performanslÄ± ve daÄŸÄ±tÄ±k sistemlerini yÃ¶netmek iÃ§in Erlang kullanmaktadÄ±r.6 AyrÄ±ca Elixir\u0026rsquo;i de PEPSICO, Discord, Change.org, Heroku gibi firmalar kullanmaktadÄ±r.7 Elixir de Erlang temelli olduÄŸundan Ã§eÅŸitli alanlarda kullanÄ±labilir.\nÃ–rneÄŸin:\nWeb GeliÅŸtirme: Phoenix framework ile birlikte kullanÄ±larak yÃ¼ksek performanslÄ± web uygulamalarÄ± geliÅŸtirilebilir. DaÄŸÄ±tÄ±k Sistemler: YÃ¼ksek eriÅŸilebilirlik ve dÃ¼ÅŸÃ¼k gecikme sÃ¼releri gerektiren sistemlerde idealdir. GerÃ§ek ZamanlÄ± Uygulamalar: AnlÄ±k mesajlaÅŸma, oyun sunucularÄ± ve IoT uygulamalarÄ± gibi gerÃ§ek zamanlÄ± sistemlerde kullanÄ±lÄ±r. Elixir, Erlang\u0026rsquo;Ä±n gÃ¼Ã§lÃ¼ yÃ¶nlerini modern bir sÃ¶zdizimi ve geliÅŸtirme deneyimi ile birleÅŸtirerek geliÅŸtiricilere sunar. Bu nedenle, Elixir telekomÃ¼nikasyon, finans, saÄŸlÄ±k ve e-ticaret gibi sektÃ¶rlerde yÃ¼ksek Ã¶lÃ§eklenebilirlik ve dÃ¼ÅŸÃ¼k gecikme sÃ¼releri gerektiren uygulamalar iÃ§in ideal bir seÃ§imdir.\nElixir Kurulum Rehberi #Elixir programlama dilini bilgisayarÄ±nÄ±za kurmak iÃ§in aÅŸaÄŸÄ±daki adÄ±mlarÄ± takip edebilirsiniz. Ä°ÅŸletim sisteminize gÃ¶re farklÄ± kurulum yÃ¶ntemleri mevcuttur.\nMacOS Ãœzerine Elixir Kurulumu # Homebrew Paket YÃ¶neticisini Kurun (EÄŸer Homebrew yÃ¼klÃ¼ deÄŸilse): /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; Elixir\u0026rsquo;i Homebrew ile Kurun: brew install elixir Ubuntu/Linux Ãœzerine Elixir Kurulumu # Paket YÃ¶neticisini GÃ¼ncelleyin: sudo apt-get update Elixir\u0026rsquo;i Kurun: sudo apt-get install erlang elixir Windows Ãœzerine Elixir Kurulumu # Erlang/OTP\u0026rsquo;yi Ä°ndirin ve Kurun:\nErlang/OTP Ä°ndir Elixir\u0026rsquo;i Ä°ndirin ve Kurun:\nElixir Ä°ndir Not: AyrÄ±ca Windows\u0026rsquo;ta Elixir\u0026rsquo;i winget, choco gibi paket yÃ¶neticileriyle de kolay bir ÅŸekilde kurabilirsiniz. Kurulum SonrasÄ± Kontroller #Elixir\u0026rsquo;in doÄŸru bir ÅŸekilde kurulduÄŸunu doÄŸrulamak iÃ§in terminal veya komut istemcisinde elixir -v komutunu Ã§alÄ±ÅŸtÄ±rabilirsiniz. Bu komut Elixir\u0026rsquo;in kurulu olduÄŸunu ve sÃ¼rÃ¼m numarasÄ±nÄ± gÃ¶sterecektir.\nelixir -v Ã‡Ä±ktÄ±sÄ±:\nErlang/OTP 24 [erts-12.2.1] [source] [64-bit] [smp:20:20] [ds:20:20:10] [async-threads:1] [jit] Elixir 1.12.2 (compiled with Erlang/OTP 24) Åimdi kurulumu baÅŸarÄ±lÄ± bir ÅŸekilde yaptÄ±ÄŸÄ±mÄ±za gÃ¶re interaktif terminalini tanÄ±yalÄ±m ve temel bilgileri Ã¶ÄŸrenmeye baÅŸlayalÄ±m.\nIEx Nedir ve NasÄ±l KullanÄ±lÄ±r? #IEx (Interactive Elixir), Elixir kodlarÄ±nÄ± interaktif olarak Ã§alÄ±ÅŸtÄ±rabileceÄŸiniz bir kabuktur(shell). IEx, Elixir dilini Ã¶ÄŸrenmek ve hÄ±zlÄ± bir ÅŸekilde kod denemeleri yapmak iÃ§in ideal bir araÃ§tÄ±r.\nIEx\u0026rsquo;in Temel Ã–zellikleri # Interaktif Ã‡alÄ±ÅŸma OrtamÄ±: Elixir kodlarÄ±nÄ± doÄŸrudan yazÄ±p Ã§alÄ±ÅŸtÄ±rabilirsiniz. AnÄ±nda Geri Bildirim: YazdÄ±ÄŸÄ±nÄ±z kodun Ã§Ä±ktÄ±sÄ±nÄ± hemen gÃ¶rebilirsiniz. GeliÅŸmiÅŸ YardÄ±m Sistemi: Elixir modÃ¼lleri ve fonksiyonlarÄ± hakkÄ±nda anÄ±nda yardÄ±m alabilirsiniz. GeliÅŸmiÅŸ Debugging ve Profiling: Kodunuzu adÄ±m adÄ±m Ã§alÄ±ÅŸtÄ±rabilir ve performans analizleri yapabilirsiniz. IEx NasÄ±l KullanÄ±lÄ±r? #IEx\u0026rsquo;i BaÅŸlatma #IExâ€™i baÅŸlatmak iÃ§in terminal veya komut istemcisinde iex komutunu yazmanÄ±z yeterlidir:\niex Sizi ÅŸÃ¶yle bir ekran karÅŸÄ±layacaktÄ±r:\nErlang/OTP 24 [erts-12.2.1] [source] [64-bit] [smp:20:20] [ds:20:20:10] [async-threads:1] [jit] Interactive Elixir (1.12.2) - press Ctrl+C to exit (type h() ENTER for help) iex(1)\u0026gt; Ã–rneÄŸin bir toplama iÅŸlemi yapalÄ±m ve sonucunu alalÄ±m. #Erlang/OTP 24 [erts-12.2.1] [source] [64-bit] [smp:20:20] [ds:20:20:10] [async-threads:1] [jit] Interactive Elixir (1.12.2) - press Ctrl+C to exit (type h() ENTER for help) iex(1)\u0026gt; 1+1 2 iex(2)\u0026gt; YardÄ±m Alma #IEx, Elixir modÃ¼lleri ve fonksiyonlarÄ± hakkÄ±nda yardÄ±m almanÄ±zÄ± saÄŸlar. YardÄ±m almak iÃ§in h komutunu kullanabilirsiniz. Ã–rneÄŸin IO.puts fonksiyonu hakkÄ±nda bilgi alalÄ±m:\niex(2)\u0026gt; h IO.puts def puts(device \\\\ :stdio, item) @spec puts(device(), chardata() | String.Chars.t()) :: :ok Writes item to the given device, similar to write/2, but adds a newline at the end. By default, the device is the standard output. It returns :ok if it succeeds. ## Examples IO.puts(\u0026#34;Hello World!\u0026#34;) #=\u0026gt; Hello World! IO.puts(:stderr, \u0026#34;error\u0026#34;) #=\u0026gt; error iex(3)\u0026gt; IEx\u0026rsquo;den Ã‡Ä±kma #IEx kabuÄŸundan Ã§Ä±kmak iÃ§in aÅŸaÄŸÄ±daki yÃ¶ntemleri kullanabilirsiniz:\nCTRL+C TuÅŸ Kombinasyonu: Ä°ki kez CTRL+C tuÅŸ kombinasyonunu uygulayÄ±n.\nSystem.halt/0 Fonksiyonu: System.halt() fonksiyonunu Ã§alÄ±ÅŸtÄ±rÄ±n.\niex\u0026gt; System.halt() Not: \u0026rsquo;/0\u0026rsquo; bu fonksiyonun parametresiz halini kullanabileceÄŸimizi gÃ¶stermektedir. Parametre sayÄ±sÄ±na gÃ¶re slash iÅŸaretinin yanÄ±ndaki sayÄ± deÄŸiÅŸebilir. Daha fazla Ã¶zelliÄŸe farklÄ± bÃ¶lÃ¼mlerde ayrÄ±ca deÄŸineceÄŸiz ÅŸimdilik temeller iÃ§in bunlarÄ± bilmek yeterli olacaktÄ±r.\nElixir in Action Second Edition by SaÅ¡a JuriÄ‡\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChatGPT\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLet It Crash\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nErlang â€œLet it Crashâ€ Approach to Building Reliable Services\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nEcto.Query\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWho uses Erlang for product development?\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCompanies using Elixir in production\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"30 Temmuz 2024","permalink":"/tr/series/elixir/1-temel-elixir-bilgisi/","section":"Series","summary":"Bu yazÄ±mÄ±zda, Elixir programlama dilinin temel Ã¶zelliklerine odaklanÄ±yoruz. Fonksiyonel programlama yaklaÅŸÄ±mÄ±nÄ± benimseyen Elixir, daÄŸÄ±tÄ±k sistemler ve yÃ¼ksek performanslÄ± uygulamalar geliÅŸtirmek iÃ§in ideal bir dil olarak dikkat Ã§ekiyor. Erlang VM Ã¼zerinde Ã§alÄ±ÅŸarak hata toleransÄ±, Ã¶lÃ§eklenebilirlik ve yÃ¼ksek hÄ±z sunan Elixir, modern yazÄ±lÄ±m geliÅŸtirme sÃ¼reÃ§lerinde Ã¶nemli bir rol Ã¼stleniyor. Yeni baÅŸlayanlar iÃ§in Elixir\u0026rsquo;in temel bilgilerini ve kurulum adÄ±mlarÄ±nÄ± detaylÄ±ca ele alÄ±yoruz.","title":"1 - Elixir nedir? NasÄ±l Kurulur ve KullanÄ±lÄ±r"},{"content":"","date":null,"permalink":"/tr/tags/elixir/","section":"Tags","summary":"","title":"Elixir"},{"content":" Bu serimizde Elixir dili hakkÄ±nda yaptÄ±ÄŸÄ±m araÅŸtÄ±rmalar ve sonucunda aldÄ±ÄŸÄ±m notlarÄ± aktarmaya Ã§alÄ±ÅŸtÄ±m. ","date":null,"permalink":"/tr/series/elixir/","section":"Series","summary":"Bu serimizde Elixir dili hakkÄ±nda yaptÄ±ÄŸÄ±m araÅŸtÄ±rmalar ve sonucunda aldÄ±ÄŸÄ±m notlarÄ± aktarmaya Ã§alÄ±ÅŸtÄ±m.","title":"Elixir"},{"content":"","date":null,"permalink":"/tr/categories/elixir-serisi/","section":"Categories","summary":"","title":"Elixir-Serisi"},{"content":"","date":null,"permalink":"/tr/tags/erlang/","section":"Tags","summary":"","title":"Erlang"},{"content":"","date":null,"permalink":"/tr/topics/cross-cutting-concerns/","section":"Topics","summary":"","title":"Cross Cutting Concerns"},{"content":"","date":null,"permalink":"/tr/topics/dapr/","section":"Topics","summary":"","title":"Dapr"},{"content":" Dapr #(Distributed Application Runtime)\nDapr\u0026rsquo;a GiriÅŸ #Dapr, mikroservis tabanlÄ± uygulamalarÄ±n geliÅŸtirilmesini ve Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ± kolaylaÅŸtÄ±ran, open-source bir sidecar Ã¼rÃ¼nÃ¼dÃ¼r.\nSidecar Pattern Nedir? #Sidecar Pattern, yardÄ±mcÄ± bir bileÅŸenin (sidecar) ana uygulamaya eklenmesiyle (container veya process), uygulamanÄ±n iÅŸ mantÄ±ÄŸÄ±na mÃ¼dahale etmeden ortak gÃ¶revlerin yÃ¼rÃ¼tÃ¼lmesini saÄŸlar. GÃ¼venlik, logging ve dinamik yapÄ±landÄ±rma gibi cross cutting concerns\u0026rsquo;leri yÃ¶netmek iÃ§in idealdir.\nCross Cutting Concerns Nedir? #Cross cutting concerns, yazÄ±lÄ±m sisteminde birÃ§ok modÃ¼l veya katmanda ortak olan ve tekrarlanan fonksiyonel Ã¶zelliklerdir. GÃ¼venlik, logging, hata yÃ¶netimi, performans izleme gibi konular bu kapsamda deÄŸerlendirilir. Bunlar, sistemin bakÄ±mÄ±nÄ± ve geniÅŸletilebilirliÄŸini artÄ±rÄ±r.\nSidecar Pattern\u0026rsquo;in AvantajlarÄ± # YardÄ±mcÄ± hizmetleri izole eder. UygulamanÄ±n modÃ¼lerliÄŸini ve yeniden kullanÄ±labilirliÄŸini artÄ±rÄ±r. YÃ¶netimi ve bakÄ±mÄ± kolaylaÅŸtÄ±rÄ±r. Ã–rnek Sidecar: Resiliency (DayanÄ±klÄ±lÄ±k) # Resiliency, bir sistemin hatalardan kurtulma ve hizmet vermeye devam etme yeteneÄŸidir. Sidecar kullanarak bir mikroservise resiliency Ã¶zellikleri\neklemek, Ã¶zellikle aÄŸ hatalarÄ± veya diÄŸer geÃ§ici sorunlar durumunda hizmet sÃ¼rekliliÄŸini saÄŸlamak iÃ§in etkilidir. Bu sidecar, otomatik yeniden deneme\n(retry), devre kesici (circuit breaker) ve zaman aÅŸÄ±mÄ± (timeout) gibi dayanÄ±klÄ±lÄ±k desenlerini uygular. Ã–rnek Sidecar: Resiliency (DayanÄ±klÄ±lÄ±k) # Bizler de sidecar\u0026rsquo;larda Ã¶rneÄŸi uygulamamÄ±za gelen trafiÄŸi sadece sidecar Ã¼stÃ¼nden alabiliriz ve gelen istekleri sidecar iÃ§erisinde resiliency gÃ¶revi\ngÃ¶recek kodlardan geÃ§iririz ve uygulamamÄ±zÄ±n ayakta olmadÄ±ÄŸÄ± durumda resiliency policy\u0026rsquo;lerine gÃ¶re tekrar istek atma veya istek durdurma sÃ¼recine geÃ§er. Dapr\u0026rsquo;Ä±n AmacÄ± ve FaydalarÄ± # Uygulama mantÄ±ÄŸÄ±nÄ± deÄŸiÅŸtirmeden daÄŸÄ±tÄ±lmÄ±ÅŸ sistemlerin yaygÄ±n ihtiyaÃ§larÄ±nÄ± karÅŸÄ±lamak iÃ§in Ã§eÅŸitli yapÄ± taÅŸlarÄ± (building blocks) ve birÃ§ok farklÄ± Ã¶zellik sunar. HTTP ve gRPC protokolleri Ã¼zerinden Ã§alÄ±ÅŸarak Ã§oklu programlama dilleriyle uyumluluk sunar. Kolay programlayabilmek iÃ§in birÃ§ok farklÄ± dilde SDK\u0026rsquo;larÄ± vardÄ±r. Dapr\u0026rsquo;Ä±n Temel BileÅŸenleri # Service Invocation* # State Management* # Secrets Management* # Configuration* # Dapr\u0026rsquo;Ä±n Temel BileÅŸenleri # Pub/Sub Messaging # Bindings # Distributed lock # Cryptography # Actors # Workflow # Dapr\u0026rsquo;Ä±n DiÄŸer Ã–zellikleri #\nResiliency* #Hata toleransÄ± saÄŸlamak iÃ§in zaman aÅŸÄ±mÄ±, yeniden deneme, devre kesici ve geri Ã§ekilme gibi politikalar tanÄ±mlamayÄ± ve uygulamayÄ± destekler.\nDapr\u0026rsquo;Ä±n DiÄŸer Ã–zellikleri #\nObservability #Open Telemetry ve Zipkin gibi protokollerle izleme verilerini toplar ve birÃ§ok gÃ¶zlemlenebilirlik aracÄ±yla entegrasyon saÄŸlar.\nDapr\u0026rsquo;Ä±n DiÄŸer Ã–zellikleri #\nSecurity #VarsayÄ±lan olarak etkin gÃ¼venlik Ã¶zellikleri sunar, API\u0026rsquo;lar, servisler ve bileÅŸenler iÃ§in uygulamaya Ã¶zel politikalar ayarlama imkanÄ± saÄŸlar. Ä°letiÅŸim mTLS ile otomatik olarak ÅŸifrelenir.\nService Invocation # Mikroservisler arasÄ± iletiÅŸim saÄŸlar. HTTP veya gRPC ile Ã§alÄ±ÅŸÄ±r. Servis keÅŸfi ve yÃ¼k dengeleme Ã¶zellikleri iÃ§erir. Servislerdeki iletiÅŸimde araya girdiÄŸi iÃ§in security, resiliency, observability gibi yapÄ±larÄ± da bu istekler Ã§alÄ±ÅŸtÄ±ÄŸÄ± anda uygulayabilir. State Management #Uygulamalarda durum (state) kalÄ±cÄ±lÄ±ÄŸÄ± saÄŸlar.\nKey/value tabanlÄ± durum depolamada gÃ¶rev alÄ±r.\nFarklÄ± Ã¼rÃ¼nler ile entegre edilebilir (Redis, MongoDB, SQLs*, In-Memory, etcd, vbâ€¦).\nState Management # apiVersion: dapr.io/v1alpha1 kind: Component metadata: name: statestore apiVersion: dapr.io/v1alpha1 kind: Component metadata: name: statestore Secrets Management #GÃ¼venlik aÃ§Ä±sÄ±ndan hassas bilgilerin korunmasÄ±nÄ± saÄŸlar.\nÅifreler, API anahtarlarÄ±, gÃ¼venlik sertifikalarÄ± gibi gizli bilgilerin yÃ¶netimini iÃ§erir.\nEriÅŸim kontrolÃ¼ ve ÅŸifreleme kullanÄ±larak gÃ¼venli bir ÅŸekilde saklanÄ±r ve eriÅŸilir.\nFarklÄ± Ã¼rÃ¼nler ile entegre edilebilir (Azure Key Vault, AWS Secrets Manager, HashiCorp Vault, vb.).\nSecrets Management # apiVersion: dapr.io/v1alpha1 kind: Component metadata: name: statestore apiVersion: dapr.io/v1alpha1 kind: Component metadata: name: statestore Configuration Management #UygulamanÄ±n Ã§alÄ±ÅŸma ÅŸeklini belirleyen ayarlarÄ±n yÃ¶netimini saÄŸlar.\nUygulama ayarlarÄ±, Ã§evresel deÄŸiÅŸkenler ve yapÄ±landÄ±rma dosyalarÄ±nÄ± iÃ§erir.\nUygulama yeniden baÅŸlatÄ±lmadan veya kod deÄŸiÅŸtirilmeden kolayca gÃ¼ncellenebilir.\nFarklÄ± Ã¼rÃ¼nler ile entegre edilebilir (Redis, Consul, Kubernetes ConfigMaps, Azure App Configuration vb.).\nConfiguration Management # apiVersion: dapr.io/v1alpha1 kind: Component metadata: name: statestore apiVersion: dapr.io/v1alpha1 kind: Component metadata: name: statestore Demo # You found the speaker notes! DinlediÄŸiniz iÃ§in teÅŸekkÃ¼rler #Kaynaklar: dapr.io - ChatGPT\nÃ–rnekler Reposu: aimtune/dapr-examples\n","date":"28 Temmuz 2024","permalink":"/tr/presentations/dapr-series/dapr-1/","section":"Presentations","summary":"Bu sunumda modern mikroservis mimarileri iÃ§in gÃ¼Ã§lÃ¼ bir sidecar aracÄ± olan \u003cstrong\u003eDapr\u003c/strong\u003e\u0026lsquo;Ä± (Distributed Application Runtime) keÅŸfedeceÄŸiz. Sunumda deÄŸinilecek Dapr konularÄ±: \u003cstrong\u003eService Invocation\u003c/strong\u003e (Servis Ã‡aÄŸÄ±rma), \u003cstrong\u003eState Management\u003c/strong\u003e (Durum YÃ¶netimi), Secrets Management (Gizli Veri YÃ¶netimi), \u003cstrong\u003eConfiguration\u003c/strong\u003e (YapÄ±landÄ±rma), \u003cstrong\u003eResiliency\u003c/strong\u003e (DayanÄ±klÄ±lÄ±k).","title":"Dapr BÃ¶lÃ¼m 1"},{"content":"","date":null,"permalink":"/tr/topics/javascript/","section":"Topics","summary":"","title":"JavaScript"},{"content":"","date":null,"permalink":"/tr/topics/node.js/","section":"Topics","summary":"","title":"Node.js"},{"content":"","date":null,"permalink":"/tr/topics/redis/","section":"Topics","summary":"","title":"Redis"},{"content":"","date":null,"permalink":"/tr/topics/sidecar-pattern/","section":"Topics","summary":"","title":"Sidecar Pattern"}]